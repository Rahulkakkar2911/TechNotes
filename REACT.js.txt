----------------------------REACT JS---------------------------

React is a javascript library for building USER INTERFACES.
like
- NETFLIX

Here Mobile Apps and Desktop Apps feel very "Reactive": Things happen instantly, you don't wait for new pages to load or actions to start.
Traditionally, in web apps, you click a link and wait for a new page to load. You click a button and wait for some action to complete.
	
	client ----------> Server
		 <----------

It is a client Side Javascript Library
All about building modern reactive interfaces for the web
Declarative,  

NORMAL VANILLA -> IMPERITIVE CODING PRACTICE -> LOW LEVEL CODE (DRY VIOLATED)

BUILDING SPAs (Singel Page Applications):
 - React can be used to control parts of HTML pages or Entire Pages.
	- "Widget" approach on a multi-page application. Some Pages are still rendered on and served by a backend server.

 - React can also be used to control the entire frontend of a web application.
	- Single-Page-Application (SPA) approach. Server only sends one HTML page, thereafter , React takes over and controls the UI.
	- Smoother UI and Better UX.
	- (NETFLIX)

-----------------------REACT ALTERNATIVES-----------------------

- REACT.js is a LEAN AND FOCUSED component based UI library. Certain features (eg. ROUTING) are added via community packages. 

- Angular.js is a Complete component-based UI framework, packed with features. Uses TypeScript. Can be Overkill for smaller projects.

- Vue.js is a Component-Based UI framework, includes most care features. A bit less popular than React & Angular.


---------Exports and Imports---------

*PERSON.js*

const person = {
	name:"max"	
}

export default person

HERE default keyword means that we just import something from that file

*UTITLITY.js*

Exporting Named Stuff ->
export const clean = () => {...}
export const baseData = 10;

*APP.js*


IMPORTS AND EXPORTS READ.

import person from './person.js'
import prs from './person.js'

//importing named stuff
import {baseData} from './utility.js'
import {clean} from './utility.js'

****************************************Components*****************************************
React makes building complex, interactive and reactive user interfaces simpler
React is all about "Components"

Why component and what is it? 
All UIs are built by the components -> building blocks
1. Reusability! -> DRY
2. Seperation of Concerns! -> Don't do too many things in one and the same place (function)
 			(-> Split big chunks of code into one and the same place <-)

How is a "Component" Built?
			HTML + CSS + JS => Components
			Components..... => UI

React allows you to create these (re-usable and reactive) components consisting of HTML and JavaScript and CSS.

React uses a declarative approach to built these components.
 - Define the desired target state(s) and let react figure out the actual javascript DOM instructions.
Here you wont write any dom updating events, with react and its components -> ITS MAGIC
					BUILD YOUR OWN custom HTML Elements

*******************************Creating first Project**************************************
for full docs -> visit create-react-app.dev
Prerequisites : NODE JS must be installed

TO create a REACT project: 

1.	$>: npx create-react-app <APP_NAME>

It will create a subfolder named as <APP_NAME> and switching to that with CD command -> 

2.	$>: cd <APP_NAME>

Then run this command to run a script that will start a local development server at port 3000 and this server will watch your code files (src), if there is any change, it will automatically update the loaded page in browser.

3.	$> npm start

By running this command, it creates preconfigured folders with some basic REACT code files and a bunch of configuration files which will help you to build that react app for production use -> a couple of transformation and optimization steps between developing any REACT App.


The Created folder contains alot of files and folders:
1. package.json -> holds all the dependencies (react + other dev dependencies)
2. SRC folder -> contains all the source code on which we will be working on.

Command to install all the dependencies -> (packg.json)

4.	$>:npm install

-> creates a node_modules folder -> holds all the packages that get install with above command.


Inside that directory, you can run several commands:

  npm start
   - Starts the development server.

  npm run build
   - Bundles the app into static files for production.

  npm test
   - Starts the test runner.

  npm run eject
   - Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you canâ€™t go back!

We suggest that you begin by typing:

 $>: cd my_first_app
 $>: npm start


**************Analysing a Standard React Project**************

Src folder is the one on which we will spend majority of our time.

SRC
 -> index.js -> this is the first code file which will be executed whenever you visit the site or basically localhost:3000 to be particular. (not exactly it will be run, but it is the starting point and before running on browsers it will be tranformed in a browser friendly version of code, as some features wont work in NORMAL JS but will work after transformation)
		 -> in this file, we import ReactDOM object from react-dom third party library, which is one of our dependencies. (Basically react is split into 2 packages : REACT and REACTDOM)

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

 -> App.js -> Contains a function named App and we then export this function and inside this function we return some HTML code which wrapped inside (parenthesis) (not regularly see, not a valid JS code) -> this is a JSX (special feature invented by th e react team and it works in JS files because of the transformation steps SRC -> PUBLIC (index.html));

PUBLIC
 -> index.html -> this is basically the only HTML file that is being used by the overall REACT application as it's a SPA.
		   -> It is the only entry point, the place where the React-Driven UI should be rendered. NOTE: In this index.html -> regular HTML DOCUMENT STRUCTURE, and if we look at the body, you will find a DIV with ID : 'root'. That's the div where we inject or attach our react-driven UI. (doesn't hold any content initially)

		   This is the root that we select in index.JS to render it, we tell react to make it root. The main place where the React app gets rendered. Then we store this root object in a variable and on that object we call render() to tell react what should be rendered in that DIV. Content inside that div should be replaced by what inside the render method-> above ex: <App />


So what is this <App />: -> 
	import App from './App';
	 - App is the component (FIRST COMPONENT) which is get rendered in the place of that element with the id of root.
	 - Root component as its the main component that will get rendered in index.js file
	 - <App /> -> Its not a regular JS syntax -> called as JSX

	
**************************JSX***************************
JSX -> JAVASCRIPT AND XML (HTML == XML) and it works in JS files as because of the npm start process running the code get transformed to more browser-friendly code before everything is being served.


In older React Projects you need to (import React from 'react') in all your components files, to be precise you need it where you write JSX code.


JSX code is just Syntactic Sugar under the hood its actually transformed to methods called on the React Object. That's we need to import it in the past.

 -> return React.createElement() -> is called when we create JSX, this function takes 3 arguments:
	1. Element which should be created (in string if built-in), if custom-component then point at the import name which is at above of the file and without string.
	2. Object that has attributes to above specified Element
	3. Content between opening and closing tags
	4
	5
	.
	.
	.
	.
	.
	jitne elements hai between opening and closing tags of (1) element
 
In previous versions the following JSX the code Which is this:
	return(
		<div>
			<h2> Let's get Started! </h2>
			<ExpenseItems items = {expenses}/>
		</div>
	);
will look like this:
	return React.createElement(
		'div',
		{},
		React.createElement('h2', {}, "Let's get Started!"),
		React.createElement(ExpenseItems, {items: expenses})
	);

That's why we need to wrap the JSX code in wrapping Div, as we can't write without wrapper in older codes, because we can't return more than 2 things.

*****************BUILDING OUR COMPONENTS****************

It is a good practice to actually putting these new components into new files so that you have one file per component.

IN THE 
	->SRC folder add
		-> COMPONENTS FOLDER
			-> here add the components source file
NOTE : Don't move App.js as it is a special kind of component, you can move it but its not considered generally.

With react we build a Component tree as components will get nested sometimes inside one another. You have the app component at the top and other nested inside it.
	
			<App/>
			/	\
		     /	 \    
		<Header>   <Tasks/>     (For example)
				/  |	\
			     /   |   \
			    /    |    \
			   /     |     \
			<Task/> <Task\> <Task\>

Here Only the top most i.e <App/> is rendered into single HTML Page. All The other components will not be rendered with this React.Render() instruction. They will be used as regular HTML elements inside of our <App/> component.

--------------How is a Component Written in REACT?----------------

1. -> Its just a Javascript Function (Special Kind of function), special due to its return structure.

2. -> We need to create a filename by name of the Component (inside src Folder ) AS (ComponentName.js, Naming convention <3 ONLY)
 
3. -> Inside it write a normal function as -> 
	
	function ComponentName(){
		return (
		 // JSX - CODE
		);
	}

4. -> and to use it we need to export it. otherwise it will be usable only in that file only.
	
	export default ComponentName;

5. ->  we can import it in any file we like, Its recommended to import it in App.js component file.

	import ComponentName from './components/ComponentName'; 

(JS knows that it will be js file as it will first search a js file named 'ComponentName');

6. -> <ComponentName></ComponentName> 
		(In the JSX-CODE)

NOTE: 1. (IMPORTANT!) Its important to name the component starting with a capital letter as REACT distinguish between custom_components and inbuilt HTML ELEMENTS
	2. You MUST have 1 ROOT ELEMENT / RETURN STATEMENT (WorkAround is Wrap the whole thing inside 1 DIV)

If the componenet don't have content in between like here -> 
<ComponentName>HERE!</ComponentName> 
you can write it as a Single closed tag -> (just like hr, br, img etc);
<ComponentName/>

-----------Adding Basic Styling to Components------------
 -> CSS files are added next to the component file in the SRC folder
 -> ComponentName.css -> filename
 -> import that file into the ComponentName for which you wrote that CSS code.
		By importing that You are telling the build process to consider the file as well;

NOTE : class = className

--------------------Dynamic Data-------------------
To Enter data that you get from anywhere before return the JSX,
You can add data in curly braces {} (variable)

 -> Dynamic Placeholders

So between these curly braces you can run basic javascript expression.

				<h2> {1 + 3} </h2>

----------------------PropS-----------------------
We can make our components reusable, by using parameters and a concept called PROPS in react.

We can pass data from a parent component to its child components.

Props are arguments passed into React components. Props are passed to components via HTML attributes.

Pass Data into our components and adding new data

EG: 	function Car(props) {
  		return <h2>I am a { props.brand }!</h2>;
	}

	function Garage() {
  		return (
    			<>
      		<h1>Who lives in my garage?</h1>
      		<Car brand="Ford" />
    			</>
  		);
	}

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(<Garage />);

If you have a variable to send, and not a string as in the example above, you just put the variable name inside curly brackets {}

Note: React Props are read-only! You will get an error if you try to change their value. We can't send object as a prop item like (new Date(2012,5,23));
 
 - prop parameter is in the function

-------------- Splitting Components---------------
Every Component is focused on one task (that can't be broken into more simpler code), and thats why react is component focused we can assign the component a task.

----------------Composition----------------
Building a UI from small components piece by piece is called as Composition.

Note: You can't use your custom components as wrappers around other kind of content (having content between opening and closing tags doesnt work for custom components as it work for built in html elements)
and for that to we work we have one special prop that is built in the react (To build resuable wrapper components)
   -> props.children
for example -> 
    <div>{props.children}</div>
{props.children} -> PlaceHolder for the content that is inside the component or we can use this inside a wrapper div

But Remember only default HTML tags support 'className', not the custom components

we can dynamically add classes to the custom components

------------------Organizing Component Files---------------------

We can create subfolders in SRC/COMPONENTS folder for components that deals with a particular function and further reduce the complexity of number of files.

EXPENSES subfolder for - Expense Related stuff
 - all the files related to expense stuff

UI subfolder for - General UI Stuff
 - CARD
 .....etc

SECTION 3 - User Interation and State
- Making Apps Interactive & Reactive

-----How We can Reaect to User Events and How such events can TRIGGER State Change?--------------

Events like (Button Click)
For all these default events,there is a prop equivalent in React, which we can add to these built-in HTML elements to listen to these events.

So instead of adding a listener as we would normally do it, (By Selecting the element and then adding a event listener to it), Instead in React we Add an Event Listener by going to the JSX element and there we add a special prop which Starts with ->
onEventName: EX: onClick
- It Adds an Event Listener for that specific Event, to that prop or attribute we assign a value -> Function();

- This function can be an anonymous function which is wriiten like Ex.2
- Its a Good Practice to write the function before returning the JSX
- Just add the refeerence in the OnEvent value, Don't Execute it
- Remember its necesaary by the elements to support that event which you are adding.

- Name your functions like this in Ex.1, Convention to follow, End with Handler start with name of the event.

Ex1:
<Button onClick = {clickHandler}></Button>

Ex2: <Button onClick = {() => {console.log("Clicked!!!")}}></Button>

------How Component Function are Executed?------

Problem : If you write a click handler and change a value in that function for a variable which is used by the returned JS and is Passed by the parent of the Current Component -> IT DOES'NT CHANGE!

But, Why? 
-> Because, REACT does'nt work like this.
Lets see how React Parses the JSX CODE and how it considers and how it Brings it on the screen.

Component is just a regular function, the only special thing about that function, is that it returns JSX. Now since it's a function, someone has to call it, and major thing to notice that we never called our component function.
Instead we just use these functions like HTML ELEMENTS in the JSX Code.

Under the hood this is almost (above) like a function call. By using our components in JSX code, We make React aware of our component functions.

Whenever react evaluates this JSX code, it will call these component functions. And these component functions stand to return JSX code, which is all the evaluated, up until there's no more JSX code to be evaluated. So react keeps on calling any component functions it encounters in JSX, then calls any functions that those functions might have returned so any elements those components might have used in their JSX code until there are no more functions left.
Then it re-evaluates the overall result and translates that into DOM instructions which renders something like this on the screen. That's how react works.

It's all started by the index.js file, Where we initially point at App component, That's the first component function which is being called and that happens when the react app is been loaded on the screen which happens when the page is been visited.

Example:
REFER REACT-DEV, The Following Components (Expense Tracker) So in the case of expenseItems.js, if react encounters this expense item, it calls this expense item component function, executes all the code in there, encounters this JSX code and calls this card function and the expenseDate function and then it goes through the JSX code of this components until there's no more component code left to call and then translates that into DOM instructions which renders.

Problem with that is, that react never repeats that React goes through all of that when the application is initially rendered, but thereafter it's done.

However in modern applications, of course you sometimes want to update what's visible on the screen, for example because a button was clicked and that button should change some text which is being output.

So we need a way of telling react that something changed and that a certain component should be re-evaluated and that's where react introduces a special concept called state.

-------------State-------------
By default, Regular variables are not triggering the re-evaluation of the Component

But if it would revaluated then it gets triggered and the regular varaible can be used to change the JSX or component code.

So To Tell REACT that it should run it again, we need to import something from REACT LIBRARY, IMporting a function called as useState().

	// named import in curly braces {}
 -> import REACT, {useState} from 'react';

useState() -> function provided by the react library and this function allows us to define values as state where changes to these values should reflect in the component function being called again.

 - It is a React Hook, and all these REACT HOOKS can be recognized by the fact that they start with word 'use' in their name.

 - HOOKS must be called inside the component function and they can't be called outside the component function and not in any nested function inside the component function. (1 Exception is there)


 - useState wants a default state value, because with useState we basically create a special kind of variable. A variable where changes will lead the component function to be called again. And Of course we can therefore assign an initial value for that special variable (INITIALIZATION) and we pass this initial value as a paramter to useState()
 
 - This useState() returns something, It gives us access to this special variable, however it not just only return that access BUT also it returns a function that we can then call to assign a new value to that variable.

 - useState() actually returns an array, Where the first value is the variable itself, the second value is that updating function, we can call this function to set that variable.

 - we can only do it inside the component function -
Ex:
	const ExpenseItem = (props) => {
       const [title, setTitle] = useState(props.title);
	

	}
- title is the value that we can use in JSX CODE
- New Value is assigned by the setTitle function, pass a new value to this function, and calling this function does'nt only assign a new value to the variable, but its managed by REACT somewhere in memory and we call this state updating function.

- The special variable will not just recieve a new value but the component function in which you called this state updating function will be executed again.
(That is what we need, we want to call the component function again when our state changes), by calling this state updating function, you're telling REACT that you wanna assign a new value to this state and that then tell REACT that the component in which this state was registered with useState should be re-evaluated. And therefore React will go ahead and execute this component function again.

 - This state updating function actually doesn't change the value right away, but instead schedules this state update. So, its not available rightaway

That's How React State works and this is the keyConcept, 
If you have data, which might change, and where changes to that data should be reflected on the user interface then you need state because a regular variables will not do the trick with state, however you can set and change values and when they do change, React will re-evaluate the component in which the state was registered and only that component, by the way not any other components, just this component in which this state was registered.

---------Closer Look at useState()-----------
UseState registers some State, So some value as a state for the component in which it is being called and To be more precise here, It registers it for a specific component instance.

For Example in REACT-DEV, under Expense Tracker project, we have used expenseItem component 3 times. Now every component item recieves its own seperate State which is detached from other states. We have 1 function defination of the component, but we are calling it 3 times and every time it's called, a new separate State is created of course in the same way, but managed independently by React. If the state of one indiviuals changes , others remain intact. So, We have seperate states, even if we create a component more than once. (CRUICAL and GOOD to have). 

If you add a console.log() in a component function itself, this will be called whenever the component function is being executed.

Short Summary of above:
 - State really is seperated on a per component instance basis

	const [title,setTitle] = useState(props.title)

- By calling useState, we tell react that it should manage some value for us. We never see that variable itself.
So we therefore just call a function. we don't assign a new value to the variable again.
How it gets the new VALUE? -> Every time we call the update function, component code executed again with new value for the variable, React will not reinitialize the State. Instead, it will detect that this State had been initialized in the past, and it will just grab the latest State which is based on some State update(we always get a brand new snapshot).

The State adds reactivity to our application, Without state our UI would never change. But with State and with listening to events, we can make sure that we can react to user input and that such input can result in a visible change on our screen.

-----------Working with Multiple States----------------
	OR   Using useState in 1 component more than once

APPROACH #1:
You can call useState more than once. You can have multiple States, multiple States slices or State pieces per component, All of these States inside of one and the same component will then also be totally separated from each other.

There is also an alternative and it depends on personal preferences, which approach you Prefer.

APPROACH #2: CASE 1
You can pass in an object as a value if you need states for dependent component.
But difference is that you need to update all three of them at once and while updating make sure that no values get lost while updating

 - Both Approaches are fine.

-------Updating States based on the previous states-------
APPROACH 2: CASE 2
Whenever this condition arrives, pass a function to the Value Updating Function of the useState variable. This function will automatically be executed by REACT and it will recieve previous state snapshot for that state in which you are calling the updating function. And in that function you should return new state snapshot.


	setUserInput((prevState) => {
            return {
                ...prevState, 
                enteredTitle: e.target.value
            }
        });

In Many cases APPROACH 2 : BOTH CASES will work fine but the thing that should be kept in mind is that REACT SCHEDULES STATE UPDATES, IT DOES'NT PERFORM IT INSTANTLY. 
But the difference in both cases of APPROACH 2 is that in CASE 1 it does'nt guarantee that REACT will give you new snapshot ALWAYS, BUT in CASE 2 it guarantees.

SO IN SUMMARY:
 - Whenever your state update depends on previous state, use function syntax.

----------------CHILD TO PARENT COMMUNICATIONS----------------
EVENT PROPS: 
We can create our own EVENT PROPS which expects functions as values and that would allow us to pass a function from a parent component to a child component and then call that function inside of the child component and when we then call a function, we can of course pass data to that function as a parameter and that's how we can communicate up from CHILD TO PARENT.

NOTE: We can't skip components in between or intermediate components from CHILD to PARENT

---------------Lifting State Up------------------
				<App/>
				/    \
			     /      \
                <Expenses/>  <NewExpense/>

Consider the Tree -> 
Here the NewExpense generates some data i.e NEW EXPENSE (DATA/STATE is generated in this component), Now it is quite common that you do generate or fetch data in a component but that you might not need that data in that component.

let's say you need the data in Expenses component, So naturally we would like to hand that data over but that doesn't work like this because we have no direct connection between two sibling components.

By Now We can only communicate from PARENT to CHILD and CHILD to PARENT.

The app component in our application has access to both the new expense and the expenses component because it renders both components in its returned JSX code, that's why we wanna utilize that. Because we can now store our state in that closest involved component. So in that parent component which has access to both involved components by lifting our state up. So by passing our generated state data from the new expense to the app component. So by passing our generated state data from the new expense to the app component.

-----Controlled and Uncontrolled Components-------

Controlled Components -> Whenever you use 2 way binding, you are controlling a component
value and changes are not handled in the components itself, but in the parent component.

Presentational components vs Statefull components,
stateless versus statefull components or dumb vs smart components
It simply means that in react app you will have couple of components which manages some state (statefull components), and some components which don't manages some state (stateless components AKA presentational or DUMB component because it doesn't have any internal state it's just there to output some data.)

-----Section 5 - Rendering Lists and Consitional Content-----
---------Rendering Lists of Data------------

When we got a bunch of objects into an array full of Component elements (JSX code), because if you do output an array of JSX elements here, like a couple of cards, then React is capable of simply rendering these elements.

an array of JSX elements as part of your JSX code, react would simply render these elements side by side, and that's what we utilize here to transform our array of objects into such an array of JSX ELEMENTS or COMPONENTS, which then are rendered by React.

So, The REACT Renders the Array elements as ->

	[<ExpenseItem/>, <ExpenseItem/>, <ExpenseItem/>]

				=	=
	<ExpenseItem/>
	<ExpenseItem/>
	<ExpenseItem/>

				=	=

	  <ExpenseItem/>  <ExpenseItem/>  <ExpenseItem/>

---------------Understanding Keys!------------------

NOTE: Whenever you get this warning! -> 
"Each child in a list should have a unique "key" prop."

It is Because React see some items almost similar inside a DIV (which is using some state variable to update the componented, when we add a new item in that DIV BLOCK
) when we add a new item in that DIV BLOCK
is that, React renders this new item as the last item in this list of div's and updates all items and replace their content, such that it again matches the order of the items in my Array and this is not great.

This is happening because to React all these items look similar and it only sees that my Array changed that it's now longer than before and hence it simply renders an additional div and it adds that at the end and then it simply walks through all the items and updates the content inside of every item to match the Array content again.

The final result, therefore is correct here but from a performance perspective this is not great because all items are visited and updated and it can even lead to bugs. (statechanges could be lost inside component which was inside that array due to overwritten of the component)

Why REACT behave like this? -> Because it has no other way  

It currently simply checks the length of the Array and then has a look at the number of items that were already rendered. The individual items all look similar to React though so it can't know where a new item should be added. That's why we get this warning

//IMPORTANT !
We have a way of telling react where a new item it should be added and we do that by going to the place where we output our list of items. We add a special PROP to that item there (Key), it will help REACT to identify indiviual items (key should be a unique ID) (You can also use, index item (available in MAP as second argument) for special key) 

You can use useState hook to update the component once we add a new item to that list.