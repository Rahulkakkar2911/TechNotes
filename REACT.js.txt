----------------------------REACT JS---------------------------

React is a javascript library for building USER INTERFACES.
like
- NETFLIX

Here Mobile Apps and Desktop Apps feel very "Reactive": Things happen instantly, you don't wait for new pages to load or actions to start.
Traditionally, in web apps, you click a link and wait for a new page to load. You click a button and wait for some action to complete.
	
	client ----------> Server
		 <----------

It is a client Side Javascript Library
All about building modern reactive interfaces for the web
Declarative,  

NORMAL VANILLA -> IMPERITIVE CODING PRACTICE -> LOW LEVEL CODE (DRY VIOLATED)

BUILDING SPAs (Singel Page Applications):
 - React can be used to control parts of HTML pages or Entire Pages.
	- "Widget" approach on a multi-page application. Some Pages are still rendered on and served by a backend server.

 - React can also be used to control the entire frontend of a web application.
	- Single-Page-Application (SPA) approach. Server only sends one HTML page, thereafter , React takes over and controls the UI.
	- Smoother UI and Better UX.
	- (NETFLIX)

-----------------------REACT ALTERNATIVES-----------------------

- REACT.js is a LEAN AND FOCUSED component based UI library. Certain features (eg. ROUTING) are added via community packages. 

- Angular.js is a Complete component-based UI framework, packed with features. Uses TypeScript. Can be Overkill for smaller projects.

- Vue.js is a Component-Based UI framework, includes most care features. A bit less popular than React & Angular.


---------Exports and Imports---------

*PERSON.js*

const person = {
	name:"max"	
}

export default person

HERE default keyword means that we just import something from that file

*UTITLITY.js*

Exporting Named Stuff ->
export const clean = () => {...}
export const baseData = 10;

*APP.js*


IMPORTS AND EXPORTS READ.

import person from './person.js'
import prs from './person.js'

//importing named stuff
import {baseData} from './utility.js'
import {clean} from './utility.js'

****************************************Components*****************************************
React makes building complex, interactive and reactive user interfaces simpler
React is all about "Components"

Why component and what is it? 
All UIs are built by the components -> building blocks
1. Reusability! -> DRY
2. Seperation of Concerns! -> Don't do too many things in one and the same place (function)
 			(-> Split big chunks of code into one and the same place <-)

How is a "Component" Built?
			HTML + CSS + JS => Components
			Components..... => UI

React allows you to create these (re-usable and reactive) components consisting of HTML and JavaScript and CSS.

React uses a declarative approach to built these components.
 - Define the desired target state(s) and let react figure out the actual javascript DOM instructions.
Here you wont write any dom updating events, with react and its components -> ITS MAGIC
					BUILD YOUR OWN custom HTML Elements

*******************************Creating first Project**************************************
for full docs -> visit create-react-app.dev
Prerequisites : NODE JS must be installed

TO create a REACT project: 

1.	$>: npx create-react-app <APP_NAME>

It will create a subfolder named as <APP_NAME> and switching to that with CD command -> 

2.	$>: cd <APP_NAME>

Then run this command to run a script that will start a local development server at port 3000 and this server will watch your code files (src), if there is any change, it will automatically update the loaded page in browser.

3.	$> npm start

By running this command, it creates preconfigured folders with some basic REACT code files and a bunch of configuration files which will help you to build that react app for production use -> a couple of transformation and optimization steps between developing any REACT App.


The Created folder contains alot of files and folders:
1. package.json -> holds all the dependencies (react + other dev dependencies)
2. SRC folder -> contains all the source code on which we will be working on.

Command to install all the dependencies -> (packg.json)

4.	$>:npm install

-> creates a node_modules folder -> holds all the packages that get install with above command.


Inside that directory, you can run several commands:

  npm start
   - Starts the development server.

  npm run build
   - Bundles the app into static files for production.

  npm test
   - Starts the test runner.

  npm run eject
   - Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can’t go back!

We suggest that you begin by typing:

 $>: cd my_first_app
 $>: npm start


**************Analysing a Standard React Project**************

Src folder is the one on which we will spend majority of our time.

SRC
 -> index.js -> this is the first code file which will be executed whenever you visit the site or basically localhost:3000 to be particular. (not exactly it will be run, but it is the starting point and before running on browsers it will be tranformed in a browser friendly version of code, as some features wont work in NORMAL JS but will work after transformation)
		 -> in this file, we import ReactDOM object from react-dom third party library, which is one of our dependencies. (Basically react is split into 2 packages : REACT and REACTDOM)

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

 -> App.js -> Contains a function named App and we then export this function and inside this function we return some HTML code which wrapped inside (parenthesis) (not regularly see, not a valid JS code) -> this is a JSX (special feature invented by th e react team and it works in JS files because of the transformation steps SRC -> PUBLIC (index.html));

PUBLIC
 -> index.html -> this is basically the only HTML file that is being used by the overall REACT application as it's a SPA.
		   -> It is the only entry point, the place where the React-Driven UI should be rendered. NOTE: In this index.html -> regular HTML DOCUMENT STRUCTURE, and if we look at the body, you will find a DIV with ID : 'root'. That's the div where we inject or attach our react-driven UI. (doesn't hold any content initially)

		   This is the root that we select in index.JS to render it, we tell react to make it root. The main place where the React app gets rendered. Then we store this root object in a variable and on that object we call render() to tell react what should be rendered in that DIV. Content inside that div should be replaced by what inside the render method-> above ex: <App />


So what is this <App />: -> 
	import App from './App';
	 - App is the component (FIRST COMPONENT) which is get rendered in the place of that element with the id of root.
	 - Root component as its the main component that will get rendered in index.js file
	 - <App /> -> Its not a regular JS syntax -> called as JSX

	
**************************JSX***************************
JSX -> JAVASCRIPT AND XML (HTML == XML) and it works in JS files as because of the npm start process running the code get transformed to more browser-friendly code before everything is being served.


In older React Projects you need to (import React from 'react') in all your components files, to be precise you need it where you write JSX code.


JSX code is just Syntactic Sugar under the hood its actually transformed to methods called on the React Object. That's we need to import it in the past.

 -> return React.createElement() -> is called when we create JSX, this function takes 3 arguments:
	1. Element which should be created (in string if built-in), if custom-component then point at the import name which is at above of the file and without string.
	2. Object that has attributes to above specified Element
	3. Content between opening and closing tags
	4
	5
	.
	.
	.
	.
	.
	jitne elements hai between opening and closing tags of (1) element
 
In previous versions the following JSX the code Which is this:
	return(
		<div>
			<h2> Let's get Started! </h2>
			<ExpenseItems items = {expenses}/>
		</div>
	);
will look like this:
	return React.createElement(
		'div',
		{},
		React.createElement('h2', {}, "Let's get Started!"),
		React.createElement(ExpenseItems, {items: expenses})
	);

That's why we need to wrap the JSX code in wrapping Div, as we can't write without wrapper in older codes, because we can't return more than 2 things.

*****************BUILDING OUR COMPONENTS****************

It is a good practice to actually putting these new components into new files so that you have one file per component.

IN THE 
	->SRC folder add
		-> COMPONENTS FOLDER
			-> here add the components source file
NOTE : Don't move App.js as it is a special kind of component, you can move it but its not considered generally.

With react we build a Component tree as components will get nested sometimes inside one another. You have the app component at the top and other nested inside it.
	
			<App/>
			/	\
		     /	 \    
		<Header>   <Tasks/>     (For example)
				/  |	\
			     /   |   \
			    /    |    \
			   /     |     \
			<Task/> <Task\> <Task\>

Here Only the top most i.e <App/> is rendered into single HTML Page. All The other components will not be rendered with this React.Render() instruction. They will be used as regular HTML elements inside of our <App/> component.

--------------How is a Component Written in REACT?----------------

1. -> Its just a Javascript Function (Special Kind of function), special due to its return structure.

2. -> We need to create a filename by name of the Component (inside src Folder ) AS (ComponentName.js, Naming convention <3 ONLY)
 
3. -> Inside it write a normal function as -> 
	
	function ComponentName(){
		return (
		 // JSX - CODE
		);
	}

4. -> and to use it we need to export it. otherwise it will be usable only in that file only.
	
	export default ComponentName;

5. ->  we can import it in any file we like, Its recommended to import it in App.js component file.

	import ComponentName from './components/ComponentName'; 

(JS knows that it will be js file as it will first search a js file named 'ComponentName');

6. -> <ComponentName></ComponentName> 
		(In the JSX-CODE)

NOTE: 1. (IMPORTANT!) Its important to name the component starting with a capital letter as REACT distinguish between custom_components and inbuilt HTML ELEMENTS
	2. You MUST have 1 ROOT ELEMENT / RETURN STATEMENT (WorkAround is Wrap the whole thing inside 1 DIV)

If the componenet don't have content in between like here -> 
<ComponentName>HERE!</ComponentName> 
you can write it as a Single closed tag -> (just like hr, br, img etc);
<ComponentName/>

-----------Adding Basic Styling to Components------------
 -> CSS files are added next to the component file in the SRC folder
 -> ComponentName.css -> filename
 -> import that file into the ComponentName for which you wrote that CSS code.
		By importing that You are telling the build process to consider the file as well;

NOTE : class = className

--------------------Dynamic Data-------------------
To Enter data that you get from anywhere before return the JSX,
You can add data in curly braces {} (variable)

 -> Dynamic Placeholders

So between these curly braces you can run basic javascript expression.

				<h2> {1 + 3} </h2>

----------------------PropS-----------------------
We can make our components reusable, by using parameters and a concept called PROPS in react.

We can pass data from a parent component to its child components.

Props are arguments passed into React components. Props are passed to components via HTML attributes.

Pass Data into our components and adding new data

EG: 	function Car(props) {
  		return <h2>I am a { props.brand }!</h2>;
	}

	function Garage() {
  		return (
    			<>
      		<h1>Who lives in my garage?</h1>
      		<Car brand="Ford" />
    			</>
  		);
	}

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(<Garage />);

If you have a variable to send, and not a string as in the example above, you just put the variable name inside curly brackets {}

Note: React Props are read-only! You will get an error if you try to change their value. We can't send object as a prop item like (new Date(2012,5,23));
 
 - prop parameter is in the function

-------------- Splitting Components---------------
Every Component is focused on one task (that can't be broken into more simpler code), and thats why react is component focused we can assign the component a task.

----------------Composition----------------
Building a UI from small components piece by piece is called as Composition.

Note: You can't use your custom components as wrappers around other kind of content (having content between opening and closing tags doesnt work for custom components as it work for built in html elements)
and for that to we work we have one special prop that is built in the react (To build resuable wrapper components)
   -> props.children
for example -> 
    <div>{props.children}</div>
{props.children} -> PlaceHolder for the content that is inside the component or we can use this inside a wrapper div

But Remember only default HTML tags support 'className', not the custom components

we can dynamically add classes to the custom components

------------------Organizing Component Files---------------------

We can create subfolders in SRC/COMPONENTS folder for components that deals with a particular function and further reduce the complexity of number of files.

EXPENSES subfolder for - Expense Related stuff
 - all the files related to expense stuff

UI subfolder for - General UI Stuff
 - CARD
 .....etc

SECTION 3 - User Interation and State
- Making Apps Interactive & Reactive

-----How We can Reaect to User Events and How such events can TRIGGER State Change?--------------

Events like (Button Click)
For all these default events,there is a prop equivalent in React, which we can add to these built-in HTML elements to listen to these events.

So instead of adding a listener as we would normally do it, (By Selecting the element and then adding a event listener to it), Instead in React we Add an Event Listener by going to the JSX element and there we add a special prop which Starts with ->
onEventName: EX: onClick
- It Adds an Event Listener for that specific Event, to that prop or attribute we assign a value -> Function();

- This function can be an anonymous function which is wriiten like Ex.2
- Its a Good Practice to write the function before returning the JSX
- Just add the refeerence in the OnEvent value, Don't Execute it
- Remember its necesaary by the elements to support that event which you are adding.

- Name your functions like this in Ex.1, Convention to follow, End with Handler start with name of the event.

Ex1:
<Button onClick = {clickHandler}></Button>

Ex2: <Button onClick = {() => {console.log("Clicked!!!")}}></Button>

------How Component Function are Executed?------

Problem : If you write a click handler and change a value in that function for a variable which is used by the returned JS and is Passed by the parent of the Current Component -> IT DOES'NT CHANGE!

But, Why? 
-> Because, REACT does'nt work like this.
Lets see how React Parses the JSX CODE and how it considers and how it Brings it on the screen.

Component is just a regular function, the only special thing about that function, is that it returns JSX. Now since it's a function, someone has to call it, and major thing to notice that we never called our component function.
Instead we just use these functions like HTML ELEMENTS in the JSX Code.

Under the hood this is almost (above) like a function call. By using our components in JSX code, We make React aware of our component functions.

Whenever react evaluates this JSX code, it will call these component functions. And these component functions stand to return JSX code, which is all the evaluated, up until there's no more JSX code to be evaluated. So react keeps on calling any component functions it encounters in JSX, then calls any functions that those functions might have returned so any elements those components might have used in their JSX code until there are no more functions left.
Then it re-evaluates the overall result and translates that into DOM instructions which renders something like this on the screen. That's how react works.

It's all started by the index.js file, Where we initially point at App component, That's the first component function which is being called and that happens when the react app is been loaded on the screen which happens when the page is been visited.

Example:
REFER REACT-DEV, The Following Components (Expense Tracker) So in the case of expenseItems.js, if react encounters this expense item, it calls this expense item component function, executes all the code in there, encounters this JSX code and calls this card function and the expenseDate function and then it goes through the JSX code of this components until there's no more component code left to call and then translates that into DOM instructions which renders.

Problem with that is, that react never repeats that React goes through all of that when the application is initially rendered, but thereafter it's done.

However in modern applications, of course you sometimes want to update what's visible on the screen, for example because a button was clicked and that button should change some text which is being output.

So we need a way of telling react that something changed and that a certain component should be re-evaluated and that's where react introduces a special concept called state.

-------------State-------------
By default, Regular variables are not triggering the re-evaluation of the Component

But if it would revaluated then it gets triggered and the regular varaible can be used to change the JSX or component code.

So To Tell REACT that it should run it again, we need to import something from REACT LIBRARY, IMporting a function called as useState().

	// named import in curly braces {}
 -> import REACT, {useState} from 'react';

useState() -> function provided by the react library and this function allows us to define values as state where changes to these values should reflect in the component function being called again.

 - It is a React Hook, and all these REACT HOOKS can be recognized by the fact that they start with word 'use' in their name.

 - HOOKS must be called inside the component function and they can't be called outside the component function and not in any nested function inside the component function. (1 Exception is there)


 - useState wants a default state value, because with useState we basically create a special kind of variable. A variable where changes will lead the component function to be called again. And Of course we can therefore assign an initial value for that special variable (INITIALIZATION) and we pass this initial value as a paramter to useState()
 
 - This useState() returns something, It gives us access to this special variable, however it not just only return that access BUT also it returns a function that we can then call to assign a new value to that variable.

 - useState() actually returns an array, Where the first value is the variable itself, the second value is that updating function, we can call this function to set that variable.

 - we can only do it inside the component function -
Ex:
	const ExpenseItem = (props) => {
       const [title, setTitle] = useState(props.title);
	

	}
- title is the value that we can use in JSX CODE
- New Value is assigned by the setTitle function, pass a new value to this function, and calling this function does'nt only assign a new value to the variable, but its managed by REACT somewhere in memory and we call this state updating function.

- The special variable will not just recieve a new value but the component function in which you called this state updating function will be executed again.
(That is what we need, we want to call the component function again when our state changes), by calling this state updating function, you're telling REACT that you wanna assign a new value to this state and that then tell REACT that the component in which this state was registered with useState should be re-evaluated. And therefore React will go ahead and execute this component function again.

 - This state updating function actually doesn't change the value right away, but instead schedules this state update. So, its not available rightaway

That's How React State works and this is the keyConcept, 
If you have data, which might change, and where changes to that data should be reflected on the user interface then you need state because a regular variables will not do the trick with state, however you can set and change values and when they do change, React will re-evaluate the component in which the state was registered and only that component, by the way not any other components, just this component in which this state was registered.

---------Closer Look at useState()-----------
UseState registers some State, So some value as a state for the component in which it is being called and To be more precise here, It registers it for a specific component instance.

For Example in REACT-DEV, under Expense Tracker project, we have used expenseItem component 3 times. Now every component item recieves its own seperate State which is detached from other states. We have 1 function defination of the component, but we are calling it 3 times and every time it's called, a new separate State is created of course in the same way, but managed independently by React. If the state of one indiviuals changes , others remain intact. So, We have seperate states, even if we create a component more than once. (CRUICAL and GOOD to have). 

If you add a console.log() in a component function itself, this will be called whenever the component function is being executed.

Short Summary of above:
 - State really is seperated on a per component instance basis

	const [title,setTitle] = useState(props.title)

- By calling useState, we tell react that it should manage some value for us. We never see that variable itself.
So we therefore just call a function. we don't assign a new value to the variable again.
How it gets the new VALUE? -> Every time we call the update function, component code executed again with new value for the variable, React will not reinitialize the State. Instead, it will detect that this State had been initialized in the past, and it will just grab the latest State which is based on some State update(we always get a brand new snapshot).

The State adds reactivity to our application, Without state our UI would never change. But with State and with listening to events, we can make sure that we can react to user input and that such input can result in a visible change on our screen.

-----------Working with Multiple States----------------
	OR   Using useState in 1 component more than once

APPROACH #1:
You can call useState more than once. You can have multiple States, multiple States slices or State pieces per component, All of these States inside of one and the same component will then also be totally separated from each other.

There is also an alternative and it depends on personal preferences, which approach you Prefer.

APPROACH #2: CASE 1
You can pass in an object as a value if you need states for dependent component.
But difference is that you need to update all three of them at once and while updating make sure that no values get lost while updating

 - Both Approaches are fine.

-------Updating States based on the previous states-------
APPROACH 2: CASE 2
Whenever this condition arrives, pass a function to the Value Updating Function of the useState variable. This function will automatically be executed by REACT and it will recieve previous state snapshot for that state in which you are calling the updating function. And in that function you should return new state snapshot.


	setUserInput((prevState) => {
            return {
                ...prevState, 
                enteredTitle: e.target.value
            }
        });

In Many cases APPROACH 2 : BOTH CASES will work fine but the thing that should be kept in mind is that REACT SCHEDULES STATE UPDATES, IT DOES'NT PERFORM IT INSTANTLY. 
But the difference in both cases of APPROACH 2 is that in CASE 1 it does'nt guarantee that REACT will give you new snapshot ALWAYS, BUT in CASE 2 it guarantees.

SO IN SUMMARY:
 - Whenever your state update depends on previous state, use function syntax.

----------------CHILD TO PARENT COMMUNICATIONS----------------
EVENT PROPS: 
We can create our own EVENT PROPS which expects functions as values and that would allow us to pass a function from a parent component to a child component and then call that function inside of the child component and when we then call a function, we can of course pass data to that function as a parameter and that's how we can communicate up from CHILD TO PARENT.

NOTE: We can't skip components in between or intermediate components from CHILD to PARENT

---------------Lifting State Up------------------
				<App/>
				/    \
			     /      \
                <Expenses/>  <NewExpense/>

Consider the Tree -> 
Here the NewExpense generates some data i.e NEW EXPENSE (DATA/STATE is generated in this component), Now it is quite common that you do generate or fetch data in a component but that you might not need that data in that component.

let's say you need the data in Expenses component, So naturally we would like to hand that data over but that doesn't work like this because we have no direct connection between two sibling components.

By Now We can only communicate from PARENT to CHILD and CHILD to PARENT.

The app component in our application has access to both the new expense and the expenses component because it renders both components in its returned JSX code, that's why we wanna utilize that. Because we can now store our state in that closest involved component. So in that parent component which has access to both involved components by lifting our state up. So by passing our generated state data from the new expense to the app component. So by passing our generated state data from the new expense to the app component.

-----Controlled and Uncontrolled Components-------

Controlled Components -> Whenever you use 2 way binding, you are controlling a component
value and changes are not handled in the components itself, but in the parent component.

Presentational components vs Statefull components,
stateless versus statefull components or dumb vs smart components
It simply means that in react app you will have couple of components which manages some state (statefull components), and some components which don't manages some state (stateless components AKA presentational or DUMB component because it doesn't have any internal state it's just there to output some data.)

-----Section 5 - Rendering Lists and Consitional Content-----
---------Rendering Lists of Data------------

When we got a bunch of objects into an array full of Component elements (JSX code), because if you do output an array of JSX elements here, like a couple of cards, then React is capable of simply rendering these elements.

an array of JSX elements as part of your JSX code, react would simply render these elements side by side, and that's what we utilize here to transform our array of objects into such an array of JSX ELEMENTS or COMPONENTS, which then are rendered by React.

So, The REACT Renders the Array elements as ->

	[<ExpenseItem/>, <ExpenseItem/>, <ExpenseItem/>]

				=	=
	<ExpenseItem/>
	<ExpenseItem/>
	<ExpenseItem/>

				=	=

	  <ExpenseItem/>  <ExpenseItem/>  <ExpenseItem/>

---------------Understanding Keys!------------------

NOTE: Whenever you get this warning! -> 
"Each child in a list should have a unique "key" prop."

It is Because React see some items almost similar inside a DIV (which is using some state variable to update the componented, when we add a new item in that DIV BLOCK
) when we add a new item in that DIV BLOCK
is that, React renders this new item as the last item in this list of div's and updates all items and replace their content, such that it again matches the order of the items in my Array and this is not great.

This is happening because to React all these items look similar and it only sees that my Array changed that it's now longer than before and hence it simply renders an additional div and it adds that at the end and then it simply walks through all the items and updates the content inside of every item to match the Array content again.

The final result, therefore is correct here but from a performance perspective this is not great because all items are visited and updated and it can even lead to bugs. (statechanges could be lost inside component which was inside that array due to overwritten of the component)

Why REACT behave like this? -> Because it has no other way  

It currently simply checks the length of the Array and then has a look at the number of items that were already rendered. The individual items all look similar to React though so it can't know where a new item should be added. That's why we get this warning

IMPORTANT! :⚠️
We have a way of telling react where a new item it should be added and we do that by going to the place where we output our list of items. We add a special PROP to that item there (Key), it will help REACT to identify indiviual items (key should be a unique ID) (You can also use, index item (available in MAP as second argument) for special key) 

You can use useState hook to update the component once we add a new item to that list.


------------------Conditional Content--------------------
We can't use long statements or flow EG: FOR , IF ELSE etc inside {}, But we can use ternary operator inside {}.
	{Condition ? true_do_this : false_do_this}

We can also use Short-Circuiting && and ||

IMPORTANT! :⚠️
We can store JSX content in variables. we can check before hand the content and then later return that.

We can have multiple return statements (returning JS) for multiple different renderings according to the condition and use-case

----------------Adding Dynamic Styles-----------------
You can use "style" prop on the element which expects a JS Object as a value. There you can provide styles like width, height etc as key's and its values as value.

if you want CSS style names (seperated with dashes) you need to have them as keys in STRING
Else You can use camelCasing 
		Ex:
			style={
					{
                    			height:'8%',
                				'background-color':'red'
					}
			};


------------SECTION 6: Styling React Components-------------
----Setting Dynamic Inline Styles----

we can add styles based on states of the component, by using ternary operator

Example: 
<label style={{color:isValid ? 'black':'red'}}>Course Goal</label>
<input style={{borderColor:isValid?'black':'red', background:isValid ? 'black': 'salmon'}} type="text"/>

Here, we know this inline styles has the highest priority, therefore we don't want to set it like that (always)

----Setting Classes Dynamically----

We can add Classes to the elements dynamically, by again using ternary operator depending upon the state of the component and use case
Example:
	<div className={`form-control ${!isValid ? 'invalid' : ''}`}>
			here isValid is the state of the component

IMPORTANT! : ⚠️
This is not scoped to that component (It applies the rules to global codebase), that's why we dont prefer to use it, Only thing is that you need to be carefull, while using it


There are problems with this approach of spilling styles to other components.

-----Styled Components-----
1 Way to avoid above problem, It is a package, It helps to build components that have certain style attached to them

				https://styled-components.com/

✅To get started, we need to install it using:
	npm install --save styled-components

✅You need to import ->
	import styled from 'styled-components';


When the styled component is rendered, class names on that component are dynamically generated by the styled components package Because what this package does in the end is it looks at the styles we set up here and then it wraps these styles into generated class names where it guarantees that every class name is unique, so that it can't spill over to other components of the app.

But now since we have unique class names for every styled component, the style set up here will never be able to affect the number of component in the app because these unique class names are really well unique per style component.

- It provides a method which will return a styled component
- This styled package have methods for all HTML elements
- Dont need to provide any selector in between as these styles will directly applied to the component

Example: 


//This syntax is called 'tagged template literal'
	
const Button = styled.button`
  font: inherit;
  padding: 0.5rem 1.5rem;
  border: 1px solid #8b005d;
  color: white;
  background: #8b005d;
  box-shadow: 0 0 4px rgba(0, 0, 0, 0.26);
  cursor: pointer;

&:focus {
  outline: none;
}

&:hover,
&:active {
  background: #ac0e77;
  border-color: #ac0e77;
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.26);
}

`;

export default Button;

----Styled Componenets & Dynamic Props----

The styled components, so the components returned by these styled components functions, forward all props you set on them to the underlying components, so to the underlying div here.

We can use Props in the styled components where we can specify what we need to
we can write props in tagged template literal as 

Example : 
	
	// Here we are adding a text dynamically by the props which are fed to the styled component 

	<FormControl invalid = {!isValid}>
        <label >Course Goal</label>
        <input type="text" onChange={goalInputChangeHandler} />
      </FormControl>

	& input {
  		display: block;
  		width: 100%;		// This function is called by the styled component function 
  		border: 1px solid ${props => props.invalid ? 'red' : '#ccc'};
		background: ${props => props.invalid ? '#ffd7d7' : 'transparent'}
  		font: inherit;
  		line-height: 1.5rem;
  		padding: 0 0.25rem;
	}

----Styled Componenets & Media Queries----
You have to write direct media queries that we write earlier in the tagged template literal as shown below:

- This will only affect that component only
Example: 
	const FormControl = styled.div`

		@media (min-width:768px){
  			width: auto;
		}
	
	`;

----Using CSS Modules----
✅To use this feature you need to create a css file as follow-up:

			filename.module.css

✅Importing the module
import styles from './Button.module.css'

This "styles" is an object which have all the classes defined in the module as its properties

✅You can apply the classes as following:

Here styles is the previous object on which we have the classes defined: 
		styles.button,......etc

<button type={props.type} className={styles.button} onClick = {props.onClick}>
      {props.children}
    </button>

In the dev tools, you will see different class is written on that component, But it is: ->
	class = "ComponentName_ClassName_SomeHash"

It does this to make it unique

- CSS Modules concept ensures that the CSS styles we set up in a CSS file are a scoped to the component we import this file into

This is actually the best method to use CSS, having our styles set up in CSS files but there's still scoped to components where we use them.

----Dynamic Styles and Media Queries with CSS Modules----
We can add dynamic classes as normal classes 
using template literal
for media queries we just need to add those in the module.css as normal media queries, and since we are specifying the class on the component therefore we dont need to do much else.


-----------Section 7: Debugging React Apps-------------

Understand the error, where it is coming from from the console. then try to understand why it is coming.

If its a logical error then use breakpoints on the src files from the developer console in the browser.
	✅Go To -> Sources -> Then from the sidebar check you will see your original code files -> select the file from where you want to stop execution and put the breakpoint on the line from where you want you check (by clicking on the line number).
	✅Use the controls and walk through the code step by step.

			----Using React DevTools----
Its a Browser Extension that can downloaded from here:

https://chrome.google.com/webstore/detail/react-developer-tools

After downloading you will get 2 tabs in Chrome Devtools:
	- Components
		- We can see a component tree by clicking this
		- we can see props of a component once we click a component
		- we can see which components render this current component
		- search for a component
		- We can also see hooks attached to a component, change the hooks (particulary state hook)

	- Profiler



------Section 9: Working with Fragments, Refs etc.---------
			------JSX LIMITATION-------
If we have adjacent root level JSX elements like in this example:
	return (
		<h2>Hi there!</h2>
		<p>This Does not work :-(</p>
	)
we'll get an error.

In REACT, You can't return more than one "root" JSX element (you also can't store more than one "root" JSX element in a variable).

Reason for this is: 
	return (
		React.createElement('h2', {}, 'Hi there!')
		React.createElement('p', {}, 'This does not work :-( ')
	
	);

You can't return more than 1 statements 

1 Workaround for it is:
	-> To simply wrap around the adjascent elements with a element.
	-> You have only 1 value to return 
	-> this could lead to a Problem named: "<div> Soup"
		
		<div>
		  <div>
		    <div>
                  <div>
			  <h2> Hello </h2>
			</div>
		    </div>
		  </div>
		</div>
	-> In bigger apps, you can easily end up with tons of unnecessary <div>s (or other elements) which could add no semantic meaning or structure to the page but are only there because of React's/ JSX' Requirement.
	-> Application can be slower

Alternative for it is:
	-> You can simply use a native JS array, you can put the adjacent elements seperated by commas
	-> We can return an array because React is able to work with arrays of JSX elements.
	-> You will get a warning because whenever you're working with an array of JSX elements, React wants a key on every element and with no exception here

Solution:
	We can use a "Wrapper Component"
		inside of it just return props.children
	->It is a Empty Component!
It's an element which won't render anything to the dom, but the requirement is met that there must be one root component

✅It's a good practice to create these types of components under Helpers Folder/Directory

Example: 
	
	const Wrapper = props => {
		return props.children
	}

	export default Wrapper;


-----React Fragments-----

✅import React, {Fragment} from 'react';

return (
	<React.Fragment>
	   <h2>Hi!</h2>
	   <p>This does'nt works</p>
	</React.Fragment>
)

	OR

return (
	<>
	  <h2>Hi!</h2>
	  <p>This does'nt works</p>
	</>
)

Its an empty wrapper component: It doesn't render any real HTML element to the DOM. But it fulfills React's/JSX' Requirement.


----React Portals----
Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.
Like Modals, Which needs to be direct child of the body or root element

✅For this, You create a Portal for the elements inside PUBLIC -> index.html -> Body ke niche 
	<div id = "backdrop-root"></div>
	<div id = "overlay-root"></div>
	<div id = "root"></div>

In the modal file, 
Create -> 
	before the Modal component function,

const Backdrop = props => {
	return (div which has backdrop class)
     EX: <div className = {classes.backdrop} onClick = {props.onConfirm}></div>
}

const ModalOverlay = props => {
	return (div which modal class)
	(Card of the Modal with its children, text button etc.)
}

On the main component add an expression  in which we need to add something.

 import ReactDOM from 'react-dom';

return (
	<>
		// This line ports the element (first argument) to the container element which is the second argument of the createPortal function.

	  {ReactDOM.createPortal(React node that should be render in JSX ,  pointer to that container where this previous node shoud be render we need to select that element by DOM API (document.getelement......))}
	</>
)


In JSX it should remain there where you want to render (in that particular component) but in reality it will ported to where it is mentioned (second argument) 

------------------------------Ref's (References)-----------------------------------

Refs provide a way to access DOM nodes or React elements created in the render method.
In the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.

✅There are a few good use cases for refs:

 - Managing focus, text selection, or media playback.
 - Triggering imperative animations.
 - Integrating with third-party DOM libraries.

Avoid using refs for anything that can be done declaratively.

For example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it.

⚠️Don’t Overuse Refs
Your first inclination may be to use refs to “make things happen” in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to “own” that state is at a higher level in the hierarchy. See the Lifting State Up guide for examples of this.




✅To Create a Ref we need to import a hook ->

⚠️Only usable inside of functional components
	import React, {useRef} from 'react';

It takes a default value you wanna initialize it to (by default undefined).
	const variable_name = useRef();

✅You can connect this ref to any Component or any HTML element by adding a "prop" to that element named "ref"
(just like "key" prop), However it is very often done for Input elements.

✅Now to that ref prop pass that variable_name which you earlier created

Example:
	const nameInputRef = useRef();

	return (
		<input ref = {nameInputRef}>
	)

 -> It returns a

--------Working of Ref--------

And now a connection will be established. The first time React reaches this code and renders this code, it will actually set the values stored in nameInputRef to the native DOM element that is rendered based on this input.

This ref value, which is being generated here always is an object, which always has a current prop and the current prop holds the actual value that ref is connected with Now, by default, it's undefined but as soon as this code ran, because of this ref prop, the nameInputRef is connected to that input and hence, it's actually the input which is being stored as a value in the current prop and what's being stored here really is the actual DOM node. So not some theoretical value or anything like that but the real DOM node,

Now, it is recommended that you don't manipulate it. Your DOM should really only be manipulated by React. But reading data from the input doesn't sound too bad because you're not changing anything with that.
 

❓Which is Better Ref's or State?

The question is whether refs or state is better. You can use either of the two. You will sometimes have use cases where you just want to quickly read a value, for example.

And if you only want to read a value and you never plan on changing anything, well, then you don't really need state because just to use state as a keylogger is not that great, It's a lot of unnecessary code and work. So if you just want to read a value, refs are probably better. In scenarios like this, it's up to you what you prefer. Refs, which are a little bit less code but you have this edge case of manipulating the DOM, or a state, which is definitely cleaner but is a bit more code.

--------Controlled Vs Uncontrolled Components--------

✅Uncontrolled Components: Uncontrolled Components are the components that are not controlled by the React state and are handled by the DOM (Document Object Model). So in order to access any value that has been entered we take the help of refs.

For instance, if we want to add a file as an input, this cannot be controlled as this depends on the browser so this is an example of an uncontrolled input.

 - Components are under the control of DOM.
 - Are Uncontrolled because during the life cycle methods the data may loss
 - Internal state is maintained
 - We access the values using refs
 - Controlled by the DOM itself
 - Has very limited control over form values and data

✅Controlled Components: In React, Controlled Components are those in which form’s data is handled by the component’s state. It takes its current value through props and makes changes through callbacks like onClick, onChange, etc. A parent component manages its own state and passes the new values as props to the controlled component.

Example: We are creating a simple form that comprises an input field with a label name and a submit button. We are creating an onSubmit function that triggers when we submit the form which shows the name that we have filled in the alert box.

 - The component is under control of the component’s state
 - These components are predictable as are controlled by the state of the component
 - Internal state is not maintained
 - It accepts the current value as props
 - Controlled by the parent component
 - Have better control on the form data and values

--------------Section 10: Advanced: Handling side effects, Using Reducers and Context----------------

--------What is an "Effect" Or a "Side Effect"---------

React library itself has one main job, 

 - to render the UI,

 - to React to our user input,
 
 - Evaluate & Render JSX
 
 - Manage State & Props
 
 - React to (User) Events & Input

 - Re-evaluate Component upon State and Prop Changes 

Side effects are everything else that might be happening in your application and a good example here is sending a Http request or storing something in browser storage. In local storage for example. But you could also think about timers or intervals which you set in your code.

These are all tasks which you of course often have to consider in your application but these tasks are all not related to bringing something onto the screen, at least not directly.

These are therefore tasks which must happen outside of the normal component evaluation and render cycle - especially since they might block/delay rendering (e.g Http Requests).

You would even create an infinite loop Because you would send the request whenever the Component function re-runs and in response to the request you change some state which triggers this function again. So therefore such side effects should not go directly into this component function because that would most likely create bugs, infinite loops or simply send too many Http requests to stick with that example.

Therefore we'll have a better tool for handling side effects and that's a special React Hook which we can use. (The useEffect Hook)

---------The useEffect() Hook---------

	useEffect(() => { .. }, [ dependencies ]);

The useEffect() Hook is simply another built in Hook which you can write inside the component function.

1️⃣ Argument : A function that should be executed AFTER every component evalutaion if the specified dependencies changed.
In this function, we can perform our side effects or multiple side effects if we want. The function passed to useEffect is a callback function. This will be called after the component renders.

In this function, we can return a function called as CLEANUP Function, This will run as a cleanup process before useEffect Executes the callback function next time and before the component is removed and it does'nt run before the first side effect function execution.
	We can use this cleanup Function to write cleanup logic like timer cleanup,....etc



2️⃣ Argument : Dependencies of this effect - the function only runs if the dependencies changed (array full of dependencies) 


The correct way to perform the side effect in our User component is as follows:

 - We import useEffect from "react"
 - We call it above the returned JSX in our component
 - We pass it two arguments: a function and an array

IMPORTANT! :⚠️ 
If you do not provide the dependencies array at all and only provide a function to useEffect, it will run after every render.

If you forget to provide your dependencies correctly and you are setting a piece of local state when the state is updated, the default behavior of React is to re-render the component. And therefore, since useEffect runs after every single render without the dependencies array, we will have an infinite loop.


useEffect, is a super important hook that helps you deal with code that should be executed in response to something and something could be the component being loaded. It could be the email address being updated. It could be anything, whenever you have an action that should be executed in response to some other action, that is a side effect and that is where a useEffect is able to help you.

❌What You Don't Need to Add in useEffect callback Function?

❌You DON'T need to add state updating functions (as we did in the last lecture with setFormIsValid): React guarantees that those functions never change, hence you don't need to add them as dependencies (you could though)

❌You also DON'T need to add "built-in" APIs or functions like fetch(), localStorage etc (functions and features built-into the browser and hence available globally): These browser APIs / global functions are not related to the React component render cycle and they also never change

❌You also DON'T need to add variables or functions you might've defined OUTSIDE of your components (e.g. if you create a new helper function in a separate file): Such functions or variables also are not created inside of a component function and hence changing them won't affect your components (components won't be re-evaluated if such variables or functions change and vice-versa)

✅So long story short: You must add all "things" you use in your effect function if those "things" could change because your component (or some parent component) re-rendered. That's why variables or state defined in component functions, props or functions defined in component functions have to be added as dependencies!

🧱 More About it
 -> https://www.freecodecamp.org/news/react-useeffect-absolute-beginners

 ✅Object properties can be used as dependencies To useEffect.

const { someProperty } = someObject;
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);

This is a very common pattern and approach

We could also write this code and it would work in the same way.

useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);


---------Debouncing----------
Debouncing is a programming practice used to ensure that time-consuming tasks do not fire so often, that it stalls the performance of the web page. In other words, it limits the rate at which a function gets invoked.

Debouncing in JavaScript is a practice used to improve browser performance. There might be some functionality in a web page that requires time-consuming computations. If such a method is invoked frequently, it might greatly affect the performance of the browser, as JavaScript is a single-threaded language. 

Example: 
    var button = document.getElementById("debounce");
    const debounce = (func, delay) => {
        let debounceTimer
        return function() {
            const context = this
            const args = arguments
                clearTimeout(debounceTimer)
                    debounceTimer
                = setTimeout(() => func.apply(context, args), delay)
        }
    }
    button.addEventListener('click', debounce(function() {
            alert("Hello\nNo matter how many times you" +
                "click the debounce button, I get " +
                "executed once every 3 seconds!!")
                            }, 3000));

Explanation: The button is attached to an event listener that calls the debounce function. The debounce function is provided with 2 parameters – a function and a Number. Declared a variable debounceTimer, which as the name suggests, is used to actually call the function, received as a parameter after an interval of ‘delay’ milliseconds. 

If the debounce button is clicked only once, the debounce function gets called after the delay. However, if the debounce button is clicked once, and again clicked prior to the end of the delay, the initial delay is cleared and a fresh delay timer is started. The clearTimeout function is being used to achieve it. 

The general idea for debouncing is: 

 - Start with 0 timeout 
 - If the debounced function is called again, reset the timer to the specified delay 
 - In case of timeout, call the debounced function Thus every call to a debounce function, resets the timer and delays the call. 

Application: Debouncing can be applied in implementing suggestive text, where we wait for the user to stop typing for a few seconds before suggesting the text. thus, on every keystroke, we wait for some seconds before giving out suggestions. Another application of debouncing is in content-loading webpages like Facebook and Twitter where the user keeps on scrolling. In these scenarios, if the scroll event is fired too frequently, there might be a performance impact, as it contains lots of videos and images. Thus the scroll event must make use of debouncing.

🤐User Typing : 
Well, the trick is that we actually save the timer and for the next keystroke, we clear it so that we only have one ongoing timer at a time and only the last timer will, therefore, complete and as long as the user keeps on typing, we always clear all other timers and therefore, we only have one timer that completes, and that completes after 500 milliseconds, which is the delay the user has to issue a new keystroke to clear this timer.

-------------useReducer--------------

Sometimes, you have more complex state - ForExample if it got miltiple states, multiple ways of changing it or dependencies to other states.

In such cases useState() then often becomes hard ot error-prone to use - it's easy to write inefficient or buggy code in such scenarios.
 
useReducer can be used as a replacement for useState() if you need "More Powerfull state management"


The useReducer Hook is the better alternative to the useState hook and is generally more preferred over the useState hook when you have complex state-building logic or when the next state value depends upon its previous value or when the components are needed to be optimized.

The useReducer hook takes three arguments including reducer, initial state, and the function to load the initial state lazily.

const [state, dispatchFn] = useReducer(reducerFn, initialArgs, initFn);

1️⃣ -state: The state snapshot used in the component re-render/re-evaluation cycle
2️⃣ -dispatchFn: A function that can be used to dispatch a new action (i.e Trigger an update of the state)

3️⃣ - reducerFn is the user-defined function that pairs the current state with the dispatch method to handle the state. A function that is triggered automatically once an action is dispatched (via dispatchFn)

4️⃣ - initialState refers to the initial arguments
5️⃣ - initFn is the function to initialize the state lazily or programmatically.

✅To use it, we need to import it first:
   import React, {useReducer} from 'react';

🔁 Re-watch 117: useReducer & useEffect



-----------------------------------------
🤐 useState VS useReducer
🧱 -> useState()
	- The main state management "tool"
	- Great for independent pieces of state/data
	- Great if state updates are easy and limited to a few kinds of updates
🧱 -> useReducer()
    - Great if you need "More Power"
	- should be considered if you have related pieces of state/data.
	- Can be helpful if you have more complex state updates

------React Context (CONTEXT API)-------
React context allows us to pass down and use (consume) data in whatever component we need in our React app without using props.

In other words, React context allows us to share data (state) across our components more easily.

When should you use React context?
React context is great when you are passing data that can be used in any component in your application.

✅These types of data include:

 - Theme data (like dark or light mode)
 - User data (the currently authenticated user)
 - Location-specific data (like user language or locale)

 Data should be placed on React context that does not need to be updated often

❓What problems does React context solve?
React context helps us avoid the problem of props drilling.

Props drilling is a term to describe when you pass props down multiple levels to a nested component, through components that don't need it.

To establish it:
1️⃣ Create a directory named "Context" or "Store" in the "src" Directory Next to components.

2️⃣ Add a component specific context javascript file in that folder, Example:
 -> For authentication
		-> add auth-context.js
 
3️⃣ In that file include React:
	-> import React from 'react';

4️⃣ write this line:

	//Context -> App or Component wide State
		React.createContext(parameter);
	//parameter -> often it is an object

    //It will return a component or an object
    const AuthContext = React.createContext({
		isLoggedIn : false
	});
5️⃣ Export this object
    export default AuthContext;

IMPORTANT! : ⚠️
The created context is an object with two properties: Provider and Consumer, both of which are components. To pass our value down to every component in our App, we wrap our Provider component around it.

🔁There are four steps to using React context:

 - Create context using the createContext method.
 - Take your created context and wrap the context provider around your component tree.
 - Put any value you like on your context provider using the value prop.
 - Read that value within any component by using the context consumer.

 🤐 Read More About:
	https://www.freecodecamp.org/news/react-context-for-beginners/

For the second part, that is the listening part (to get access to our value), and we can listen in two ways.

1️⃣ - by using Context consumer
2️⃣ - by using a React Hook. (Mostly Used!)

1️⃣ By first way we need to wrap the component where we want to use the Context Value:

wherever we want to consume (or use) what was provided on our context, we use the consumer component Context.Consumer, To use our passed down value, we use what is called the "render props pattern". It is just a function that the consumer component gives us as a prop. And in the return of that function, we can return and use value.

<Context.Consumer>
 ... Here we write a function to which we got argument which has the context data (object which we created in beginning).
	{(ctx) => {
		here .. we return the JSX code which have access to that data.
	}}
</Context.Consumer>

IMPORTANT! : ⚠️
Technically, we don't need a Provider if we are providing a default value to the context 

We need to pass a prop on Context.Provider named exactly as "value" on which we provide the default values

We can pass anything from functions to values,.... strings etc.

----------useContext Hook------------

1️⃣ Import it:
	import React , {useContext} from 'react';

2️⃣ Call it in the react component function where you want to use it: PassIt the context which you want to use

	const ctx = useContext(AuthContext);

👍 You can also create your own custom Provider Component as following in the context file:

	const AuthContext = React.createContext({
		isLoggedIn : false,
		onLogout: ()  => {},
		onLogin: () => {}
	});
	//custom Provider Function
	const AuthContextProvider = (props) => {
		//Can be used to bind entire logic
		const [isLoggedIn, setIsLoggedIn] = useState(false);
		
		
		useEffect(() => {
			const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
			if(storedUserLoggedInInformation === '1'){
				setIsLoggedIn(true);
			}
		}, [])

		const logoutHandler = () => {
			localStorage.removeItem('isLoggedIn')
			setIsLoggedIn(false);
		}

		const loginHandler = () => {
			localStorage.setItem('isLoggedIn', '1')
			setIsLoggedIn(true);
		}
		
		return <AuthContext.Provider>props.children</AuthContext.Provider>
	}


Now you can use this AuthContextProvider component and wrap it over your App Component

--------Context Limitation-------
⚠️React Context is NOT optimised for high frequency changes!
 -> For example, if you have state changes every second or multiple times per second. 
 -> For that we will utilize something known as Redux

⚠️React Context also should'nt be used to replace ALL component communications and props.

 -> Component should still be configurable via props and short 'prop chains' might not need any replacement.

 ----------------Rules of Hooks------------------

 1️⃣ Only Call React Hooks in React Functions, and in Custom Hooks.

 2️⃣ Only call React Hooks at the TOP LEVEL
	 - Don't call them in Nested Functions
	 - Don't call them in any Block statements
 3️⃣ Unofficial Rule for useEffect(): Always add everything you refer to inside of useEffect() as a dependency!
 
----useImperativeHandle Hook-----
Forward Ref's


------------React:BTS-------------

😵‍💫How does REACT Works? 
React -> "A Javascript library for building UI's"

ReactDOM -> Interface to the WEB
React JS does not know the web, it doesnt know anything about the browser, It only knows how to work with components.
It is ReactDOM which ultimately neeeds to bring real HTML elements to the screen.

React Only cares about the components (RealDOM - what user see), props (Data from parent component), state (internal data), context (component wide data).

whenever props, state or context changes, components that use these concepts are updated by React and React checks whether this component now wants to draw something new onto the screen and if that should be the case, React will let ReactDOM know about that so that ReactDOM is able to bring that new screen.

❓How Exactly Does all that work?
React is concerned about components and what React in the end does is, it uses a concept called the virtual DOM. It determines how the component tree, which your app is building in the end, and every component itself, of course, has a sub tree, that JSX code returned by that component.
It determines how that component tree currently looks like and what it should look like, for example, after a state update and that information is then handed off to ReactDOM which now knows about the differences and which then knows how it should manipulate the real DOM to match that virtual DOM (that virtual snapshot React derived)

whenever state props, or a context of a component changes, that component function is re-executed, that component is re-evaluated by React.

IMPORTANT! : ⚠️
Re-evaluating a component is not same as re-rendering the DOM. So just because a component function is re-executed by React does not mean that the respective part of the actual real DOM is re-rendered or re-evaluated. Instead we have to differentiate between our component part, our React part and the real DOM.

Now the real DOM on the other hand is only updated in the places where it needs to be changed based on that difference React derived between the previous state of a component and its tree and the current state after the state prop or context change.

So the real DOM is not changed all the time. It's changed rarely and only when needed. And that's important for performance. Because making a virtual comparison between the previous state and the current state, that's fairly cheap and easy to do and that happens only in memory. Reaching out to the real DOM, (that's rendered in the browser)
is pretty expensive from a performance perspective, because working with the real DOM just turns out to be a performance intensive task. 
Ofcourse not a tiny change in one place, but if you do that tiny change in a lot of places all the time, then your page might become slow because you're working with the real DOM too much.
And that's why React has this structure of doing virtual comparisons with that virtual DOM  and then only passing the changes between your last snapshot and the current snapshot to the real DOM.

That's how React works.

🤐Virtual DOM diffing
Finding out the difference between two snapshots.

Example: 
	🫣Previous Evaluation Result:

	<div>
	  <h1>Hi there!</h1>
	</div>

all of a sudden we want to show a new paragraph
	🫣Current Evaluation Result:
	
	<div>
	  <h1>Hi there!</h1>
	  🔁<p>This is new!</p>
	</div>

In this case, React would determine that the difference between both snapshots is this p tag and it would report does change to ReactDOM 
so that ReactDOM can update the real DOM and insert this paragraph. ReactDOM would not re-render the entire DOM. It would not touch this existing h1 or div element. It would only insert the paragraph after the h1 element inside of the div.

IMPORTANT! : ⚠️
-> All  JSX elements in the end are like function calls to the respect of component functions.
If the parent component function runs again of course the child component functions also runs again. So in the end, the prop value doesn't even matter here for this component to be executed again.

-> if a component is re-executed all its child components will also be re-executed and re-evaluated.

🫣🤐❓isn't this bad?
Well, this certainly costs some performance. Of course, we got ongoing function executions. We got a virtual comparison. It's needless to say that React is highly optimized for those executions and comparisons.

But we can as a developer can tell React that it should only re-execute a component under certain circumstances and those circumstances would be that the props, which the component received, changed!

React.memo(); -> it can help here
wrap the component function returned value to it, can be done while exporting it:

This only works for functional components and not for class based components.

Components in React are designed to re-render whenever the state or props value changes. However, this can impact your application's performance because, even if the change is only intended to affect the parent component, every other child component attached to the parent component will re-render. When a parent component re-renders, so do all of its child components.

React Memo is a higher-order component that wraps around a component to memoize the rendered output and avoid unnecessary renderings. This improves performance because it memoizes the result and skips rendering to reuse the last rendered result.

There are two ways you can wrap your component with React.memo(). It is either you wrap the actual component directly without having to create a new variable to store the memoized component:

	const myComponent = React.memo((props) => {
    	/* render using props */
	});

	export default myComponent;

if the parent component changed but the prop values for that component here did not change, component execution will be skipped.

Another option is to create a new variable to store the memoized component and then export the new variable:

	const myComponent = (props) => {
    	/* render using props */
	};

	export const MemoizedComponent = React.memo(myComponent);	

myComponent outputs the same content as MemoizedComponent, but the difference between both is that MemoizedComponent render is memoized. This means that this component will only re-render when the props change.

IMPORTANT! : ⚠️
A memoized component will only re-render when there is a change in props value or when the state and context of the component change.

🫣When to use React.memo()❓

You now know what it means to memoize a component and the advantages of optimization. But this doesn’t mean you should memoize all your components to ensure maximum performance optimization of performance 🙃.

It is important to know when and where to memoize your component else it would not fulfill its purpose. For example, React Memo is used to avoid unnecessary re-renders when there is no change to the state or context of your component. If the state and content of your component will ALWAYS change, React Memo becomes useless. Here are other points:

 - Use React Memo if your component will render quite often.
 - Use it when your component often renders with the same props. This happens to child components who are forced to re-render with the same props whenever the parent component renders.
 - Use it in pure functional components alone. If you are using a class component, use the React.PureComponent.
 - Use it if your component is big enough (contains a decent amount of UI elements) to have props equality check.

IMPORTANT:
In below Example:
The memoized Profile component will always render even when the user object does not change:

	<!-- Profile.js -->
	import React from 'react';

	const Profile = React.memo(({ userDetails }) => {
		console.log('profile rendered');
		return (
			<div>
				<p>{userDetails.name}</p>
				<p>{userDetails.age}</p>
				<p>{userDetails.userName}</p>
			</div>
		);
	});
	export default Profile;

React Memo doesn't work because it only performs a shallow comparison of the component's properties. Every time the app is updated, the user variable is re-declared, which happens when you use objects. To fix this, use the second argument and provide a custom comparison function.

	<!-- Profile.js -->
	import React from 'react';

	const Profile = React.memo(({ userDetails }) => {
			console.log('profile rendered');
			return (
				<div>
					<p>{userDetails.name}</p>
					<p>{userDetails.age}</p>
					<p>{userDetails.userName}</p>
				</div>
			);
		},(prevProps, nextProps) => {
			if (prevProps.userDetails.name === nextProps.userDetails.name) {
				return true; // props are equal
			}
			return false; // props are not equal -> update the component
		}
	);
	export default Profile;

❌When to AVOID using REACT MEMO?

You now understand how to use React Memo, but it is important to note that you should not use it in all situations because it does not always work as expected. Performance-related changes that are implemented incorrectly can even harm performance.

When you need to remember the values of a function or an object, you can use hooks like useMemo() and useCallback(). Also, avoid using React Memo if the component is light and renders with multiple props.

Finally, never use React Memo to wrap a class-based component; instead, extend PureComponent or implement the shouldComponentUpdate() method.

-----------useCallback() Hook-----------
useCallback is a React Hook that lets you cache/save/store a function definition between re-renders.

	const cachedFn = useCallback(fn, dependencies)

Call useCallback at the top level of your component to cache a function definition between re-renders:

fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On subsequent renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.

Dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body.The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.

IMPORTANT! : ⚠️
A component might get removed, and in that case, if it's then later reattached, a new state would be initialized. But as long as a component stays attached to the DOM, state is only updated after that first initialization.
 - same is true for useReducer

State Updates and State Scheduling:

Calling state updating functions in general schedules a state update. React is aware of it, React plans on processing it,
React doesn't process that immediately though. 

Now in reality most of the time, state changes, scheduled state changes will be processed very fast, pretty much instantly. But React reserves the right of actually postponing that state change. React might postpone scheduled state changes.

Now, what React does is, it guarantees you that the order of state changes for one in the same type of state is guaranteed. once that state change was processed, React will re-evaluate the component, it will re-run the component function.

Because of that scheduling where of course you might have multiple outstanding scheduled state changes at the same time, because of that, multiple updates can be scheduled at the same time, because of that, it is recommended that you use this function form for updating your state if you depend on the previous state snapshot. but because it theoretically could be postponed, this is the safe way of ensuring that state changes are processed in order and for every state change where you depend on the previous state,

That's why this function form is helpful because there React will actually ensure that for every outstanding state change, it looks into the latest state and gives you that and does not use the latest state from the last time the component was re-rendered. That's an important difference between when the component was re-rendered and when a state change was scheduled.


---------Batching---------

if you have two state updates in the same synchronous code snippet after each other (in the same function), for example, where nothing in between would cause a time delay or anything like that. In such cases, React will batch those state updates together.

For Exapmle:
In one long synchronous process, so for example, in one function that executes start to end without any callbacks or promises in between, in such cases React will take all the state updates that are produced by that function and it will batch them together into one state update.

----------------useMemo() Hook-------------------

useMemo is a React Hook that lets you cache the result of a calculation between re-renders.

   const cachedValue = useMemo(calculateValue, dependencies)

Call useMemo at the top level of your component to cache a calculation between re-renders.

1️⃣calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On subsequent renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it in case it can be reused later.

2️⃣dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.

On the initial render, useMemo returns the result of calling calculateValue with no arguments.

During subsequent renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned.

IMPORTANT! : ⚠️
✅useMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.

✅In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.

✅React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.

-----------------Section 13: An Alternative Way of Building Componenets: Class Based Components------------------

            🔁SKIP THIS SECTION UNTILL COURSE FINISHES

-----------------Section 14: Sending Http Requests (e.g. connecting to the database)------------------
AXIOS (a package for javascript) could be used to send http requests 
Fetch API : BUILT into Browsers, allows to send and fetch some data to/from the API

✅If we are fetching a resource from an API and we got an unsuccessful status code. By default, the Fetch API doesn't throw back an error. Axios, on the other hand, would generate and throw a real error for error status codes.

✅You can use States for various states like Loading, error, loadedResource etc.....

✅useEffect can be used to do side works like fetching data immediately after the component loads side by side preventing infinite loop; 

----------------Section 15: Building Custom React Hooks-------------------

Custom React JS hooks are reusable functions that a React JS software developer can use to add special and unique functionality to the React applications. Usually, if there is a requirement to add a feature, one can install a third-party library and solve the problem. But what if there is no such library with hooks that can be used? This problem is solved by using custom React JS hooks.

A custom hook is a special JavaScript function whose name starts with ‘use’ and can be used to call other hooks. Let’s take a look at some major differences between a custom React JS hook and React JS components:

 - A custom hook does not require a specific signature.
 - A software developer can choose what argument the custom hook has and what should the argument return.
 - A custom hook always starts with the name ‘use’.

 ✅ Outsource stateful logic into re-usable functions.
 unlike "regular functions", custom hooks can use other react hooks and react state.
 
 ⭐ How can we create a custom Hook?
1️⃣ like components, we create a seperate directory for our custom "Hooks"

2️⃣ Create a file, by naming like use-< useForTheHook >.js
Example:
	🫣use-counter.js









✅If you call a custom hook in one of your components and that component, for example of registers a state or an effect, then this state and effect will be tied to the component in which you use your custom hook.

✅If we use a custom hook in multiple components, every component will receive its own state.

You can return whatever you wanna return in your custom hooks. Could be an array or an object or a number or a state variable.

---------------------------------------Section 18: Diving deep into REDUX--------------------------------------------

⭐Redux is a third party react library.

✅Redux is a state management system for a cross-component or app-wide state. So it helps us manage state (data that changes and affects our application) and what we display on the screen.

✅It helps us manage such data across multiple components or even the complete app.

❓What is Cross-Component/App-Wide state

So, There are three main kinds of state.
1️⃣ Local state
 -> It is a state which belongs to a single component 
 -> For example, if we listen to a user input and we use useState to store that input with every keystroke in a state variable.
               Or 
We have a button that toggles some detailed field. So if we click that button we show the details, if we click it again we hide them.
It should be managed component-internal with useState() / useReducer().


2️⃣ Cross-Component
-> It is a state that affects multiple components
-> For example, if we have a button that opens or closes a modal overlay such a modal component might affect multiple components and the trigger for opening the modal is per definition not inside of the modal. On the otherhand, the modal might be closed by clicking a button which is inside of that modal.

So, then we have multiple components working together to display and hide a modal.

-> Require "prop chains" / "prop drilling"
3️⃣ App-Wide State
-> Is is a state that does not just affect multiple components but basically all components of an application.
-> For example: user authentication, If we log in we might need to change the navigation bar because we now show new options and we also certainly affect a lot of other components which now show more or less data. 
-> Requires "props chains" / "props drilling"

For cross-component and app-wide state passing around data and updating function through props can become cumbersome though.

Redux solves the same problem. So both REACT CONTEXT and REDUX are there to help us manage such cross-component or app-wide States.

You can also use both Contexts and Redux in the same application.

REACT CONTEXT vs REDUX😵‍💫
-> REACT CONTEXT has a couple of potential disadvantages.
   -> With React Context, you can have a very complex setup and managing state with React Context can become quite complex. You can end up with deeply nested JSX code.

-> Performance can be an issue, it works good for low frequency states updates like theme changing, authentication but for high frequency state updates its not well suited - as quoted by an Official React TEAM Member.

❓How REDUX Works?

Redux is all about having one Central Data (state) Store, in your application.
You have exactly one store. You never have more than one store.
It's one store, for all your state for your entire application.

In that state you could store authentication, themeing .... etc.

For this components set up subscriptions, to our Central Store. They subscribe to the store, and whenever the data changes, the store notifies components, and then components can get the data they need, for example the current authentication status, so they get a slice of the Redux store, and they can then use it.

      |--------------------Reducer function
	|   (forwarded to)        |
	|				  | Mutates (= changes) Store Data
	|				  |
	|				  V
   Action		    CENTRAL DATA (STATE)
    	|				  |
	|				  | (Subscriptions)
	|				  |
	|	   (Dispatch)	  V
	|---------------------Components

⚠️Components Never, directly manipulate the store data. So we have that subscription, but we don't have a data flow in the other direction. (At least not a direct data flow.)

Instead for that, we use a concept called REDUCERS. We have a reducer function. This reducer function which we have to set up. This function is responsible, for mutating. So for changing the store data.

	             useReducer !== reducer (here)

😵‍💫How do we now connect components and that reducer function?

it will ofcourse be the components that should trigger a data change. It is for example a click on a button in a component that should trigger some data change. So how do we connect that?
(Trigger)We have actions and components dispatch actions.


Now an action is really just a simple JavaScript object, which describes the kind of operation, the reducers should perform. Therefore, Redux then forwards actions to the reducer, reads that description of the desired operation, and then this operation is performed by the reducer.

So components dispatch actions, which describe what should be done, but don't do it directly, then these actions are forwarded to the reducer, the reducer then does what the action wants, the reducer to do and then the reducer, spits out a new state, which effectively will replace the existing state in that Central Data Store and when that happens, subscribing components are notified, so that they can update their UI.

That's how Redux works!🫣

🛣️Principles of Redux
Predictability of Redux is determined by three most important principles as given below −

1️⃣Single Source of Truth
The state of your whole application is stored in an object tree within a single store. As whole application state is stored in a single tree, it makes debugging easy, and development faster.

2️⃣State is Read-only
The only way to change the state is to emit an action, an object describing what happened. This means nobody can directly change the state of your application.

3️⃣Changes are made with pure functions
To specify how the state tree is transformed by actions, you write pure reducers. A reducer is a central place where state modification takes place. Reducer is a function which takes state and action as arguments, and returns a newly updated state.

🪜To install redux, you can follow the below steps −

✅Run the following command in your command prompt to install Redux.

	> npm install --save redux

✅To use Redux with react application, you need to install an additional dependency as follows −

	> npm install --save react-redux


✅To install developer tools for Redux, you need to install the following as dependency −

Run the below command in your command prompt to install Redux dev-tools.

	> npm install --save-dev redux-devtools

👥How to use Redux?
A reducer function is a standard JavaScript function, but it will it be called by the Redux library and it will then always receive two pieces of input, two parameters, 
 
1️⃣ - the old or existing state and 
2️⃣ - the action that was dispatched.

then this reducer function must return a certain output. It must always return a new state object. And therefore a reducer function should be a pure function. Which basically means that the same inputs, the same values for inputs always should produce exactly the same output.

🫣Example - How to use it?
Let us assume our application’s state is described by a plain object called initialState which is as follows −

	const initialState = {
   		isLoading: false,
   		items: [],
   		hasError: false
	};

Every piece of code in your application cannot change this state. To change the state, you need to dispatch an action.

🎬What is an action?
An action is a plain object that describes the intention to cause change with a type property. It must have a type property which tells what type of action is being performed. The command for action is as follows −

	return {
   		type: 'ITEMS_REQUEST', //action type
   		isLoading: true //payload information
	}
Actions and states are held together by a function called Reducer. An action is dispatched with an intention to cause change. This change is performed by the reducer. Reducer is the only way to change states in Redux, making it more predictable, centralised and debuggable. A reducer function that handles the ‘ITEMS_REQUEST’ action is as follows −

	const reducer = (state = initialState, action) => {
   		switch (action.type) {
      		case 'ITEMS_REQUEST':
         			return Object.assign({}, state, {
            		isLoading: action.isLoading
         			})
      		default:
         			return state;
   		}
	};

Redux has a single store which holds the application state. If you want to split your code on the basis of data handling logic, you should start splitting your reducers instead of stores in Redux.

Redux follows the unidirectional data flow. It means that your application data will follow in one-way binding data flow. As the application grows & becomes complex, it is hard to reproduce issues and add new features if you have no control over the state of your application.

Redux reduces the complexity of the code, by enforcing the restriction on how and when state update can happen. This way, managing updated states is easy. We already know about the restrictions as the three principles of Redux. Following diagram will help you understand Redux data flow better (In The Github).

⭐⭐⭐⭐⭐⭐⭐⭐⭐ Attach the link

An action is dispatched when a user interacts with the application.

The root reducer function is called with the current state and the dispatched action. The root reducer may divide the task among smaller reducer functions, which ultimately returns a new state.

The store notifies the view by executing their callback functions. The view can retrieve updated state and re-render again.

🏪What is a Store?

A store is an immutable object tree in Redux. A store is a state container which holds the application’s state. Redux can have only a single store in your application. Whenever a store is created in Redux, you need to specify the reducer.

Let us see how we can create a store using the createStore method from Redux. One need to import the createStore package from the Redux library that supports the store creation process as shown below −

	import { createStore } from 'redux';
	import reducer from './reducers/reducer'
	const store = createStore(reducer);

A createStore function can have three arguments. The following is the syntax −

	createStore(reducer, [preloadedState], [enhancer])

A reducer is a function that returns the next state of app. A preloadedState is an optional argument and is the initial state of your app. An enhancer is also an optional argument. It will help you enhance store with third-party capabilities.

A store has three important methods as given below.

1️⃣getState()
It helps you retrieve the current state of your Redux store. The syntax for getState is as follows −

	store.getState()

2️⃣dispatch()
It allows you to dispatch an action to change a state in your application. The syntax for dispatch is as follows −

	store.dispatch({type:'ITEMS_REQUEST'})
3️⃣subscribe()
It helps you register a callback that Redux store will call when an action has been dispatched. As soon as the Redux state has been updated, the view will re-render automatically. The syntax for dispatch is as follows −

store.subscribe(()=>{ console.log(store.getState());})
Note that subscribe function returns a function for unsubscribing the listener. To unsubscribe the listener, we can use the below code −

	const unsubscribe = store.subscribe(()=>	{console.log(store.getState());});
	unsubscribe();

🍒What is a Reducer?
Reducers are a pure function in Redux. Pure functions are predictable. Reducers are the only way to change states in Redux. It is the only place where you can write logic and calculations. Reducer function will accept the previous state of app and action being dispatched, calculate the next state and returns the new object.

The following few things should never be performed inside the reducer −

❌Mutation of functions arguments
❌API calls & routing logic
❌Calling non-pure function e.g. Math.random()

The following is the syntax of a reducer −

	(state,action) => newState

we can write our logic in reducer and can split it on the logical data basis. Let us see how we can split reducers and combine them together as root reducer when dealing with a large application.

Suppose, we want to design a web page where a user can access product order status and see wishlist information. We can separate the logic in different reducers files, and make them work independently. Let us assume that GET_ORDER_STATUS action is dispatched to get the status of order corresponding to some order id and user id.


IMPORTANT! : ⚠️
There should be no side effects inside of that function. So you must not send a HTTP request or write something to local storage or fetch something from local storage there.

/reducer/orderStatusReducer.js
import { GET_ORDER_STATUS } from ‘../constants/appConstant’;
export default function (state = {} , action) {
   switch(action.type) {
      case GET_ORDER_STATUS:
         return { ...state, orderStatusData: action.payload.orderStatus };
      default:
         return state;
   }
}


/reducer/getWishlistDataReducer.js
import { GET_WISHLIST_ITEMS } from ‘../constants/appConstant’;
export default function (state = {}, action) {
   switch(action.type) {
      case GET_WISHLIST_ITEMS:
         return { ...state, wishlistData: action.payload.wishlistData };
      default:
         return state;
   }
}

we can combine both reducers by using Redux combineReducers utility. The combineReducers generate a function which returns an object whose values are different reducer functions. You can import all the reducers in index reducer file and combine them together as an object with their respective names.

/reducer/index.js
import { combineReducers } from ‘redux’;
import OrderStatusReducer from ‘./orderStatusReducer’;
import GetWishlistDataReducer from ‘./getWishlistDataReducer’;

const rootReducer = combineReducers ({
   orderStatusReducer: OrderStatusReducer,
   getWishlistDataReducer: GetWishlistDataReducer
});
export default rootReducer;

Now, you can pass this rootReducer to the createStore method as follows −

const store = createStore(rootReducer);

STEPS TO FOLLOW WHILE WORKING WITH REACT and REDUX ALTOGETHER!

1️⃣ Install npm package : react-redux
	> npm i react-redux
	> npm i redux
2️⃣Create the store directory in the react app and create an index.js file inside it, and write the following accordingly:
	//creating the store
	import {createStore} from 'redux';

	//creating the reducer function
	const counterReducer = (state = {counter: 0},action) => {
	if(action.type === 'INCR'){
		return {
			counter: state.counter + 1
		}
	}
	if(action.type === 'DECR'){
		return {
			counter: state.counter - 1
		}
	}
	return state;
	};

	//creating the store
	const store = createStore(counterReducer);

	//export the store
	export default store;
IMPORTANT! : ⚠️
The object which we are returning in our reducer, in our Redux reducer, return a brand new snapshot, a brand new state object which Redux will use to replace its existing state with, So the objects which we return will not be merged with the existing state. They will overwrite the existing state.

So we must always set all the other states when we update a piece of state because we overwrite the old state.

❌You should never super important never mutate the state, the existing state.

❌	if(action.type === 'INCR'){
			state.counter++;
			return state;
		}
✅Instead, always override it by returning a brand new state object.


This can lead to bugs, unpredictable behavior and it can make debugging your application harder as well.
So even though it doesn't lead to a bug here it can have unwanted and unexpected side effects in bigger applications where your state gets out of sync and suddenly the UI is not reflecting your state correctly anymore.

✅Do this in an immutable way

3️⃣ Provide the store to the app or the highest level >
by going to the react "index.js" file in the "SRC" folder

	import React from 'react';
	import ReactDOM from 'react-dom/client';
    ⭐  import { Provider } from 'react-redux';

	import './index.css';
	import App from './App';

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(
	⭐	<Provider>
			<App />
	⭐	</Provider>
	);

You could also wrap nested components (not only the highest one) with provider, but only wrapped components and their child components, and their child components of the child components, and so on. Only those components will have access to Redux thereafter.

Now just by wrapping Provider around app, we're not telling react Redux and react therefore  which store we wanna provide.

So, we have to import store from our index.js file in Store directory.

	import store from './store/index'

and then therfore tell provider that you are providing this store by:
pointing that imported store on the special prop that is available on Provider.

	<Provider store={store}>

Now the app and its child components i.e the whole app can use the store.
🫣They can get data out of the store.

🫣They can set up a subscription to that data to be precise.

🫣They also can dispatch actions.

-----useSelector Hook, useDispatch-----

----useSelector----
- useSelector is a function that takes the current state as an argument and returns whatever data you want from it. It’s very similiar to mapStateToProps() and it allows you to store the return values inside a variable within the scope of you functional components instead of passing down as props.

- used to select/get part of the state managed by redux.

- When you use useSelector(), react-redux will automatically set a subscription to the redux store for this component in which you are using useSelector() and will recieve the latest value automatically whenever that changes in the redux store (that you are getting as a part of the state)

- Its automatically reactive Changes to the Redux store will cause the component function to be re executed.

- If you ever would unmount/remove the component which is utilizing the store, React Redux would also automatically clear the subscription for you. So,  it manages that subscription for you behind the scenes.


-----useDispatch------

 - useDispatch is a function that we import from react-redux library and assign it to a variable. And with this, we are able to dispatch any action to the store by simply adding an action as an argument to the new variable like the code above and that’s it.

 - returns a dispatch function a function which we can call, which will dispatch an action against our Redux store.

----Attaching payloads to actions----
We can't predict all possible values we might wanna support in the actions (in the reducer function),

you can't hard-code those values here in your Reducer.

Instead, the action which we dispatch and which reaches the Reducer often needs to carry extra data.

⭐whatever you want to configure
	const payload = {...}

	dispatch({type: 'action-name', payload});

- It adds dynamism to the reducer function

------Redux: TOOLKIT------
⌚working with redux alot easier.

TO start working:
	> npm i @reduxjs/toolkit

After installing you can then uninstall redux library because that is already included in this package.

For docs refer: 
	https://redux-toolkit.js.org/
 
------Section 22: Deployment of REACT APPS-------

☁️-----------------------☁️

Development ------> Production

⌚☁️ How and what steps to be taken?
1️⃣ Test the App first thoroughly

2️⃣ Optimize the code (add lazy loading)

3️⃣ Build App for Production
	-> execute a script, which will output production ready code automatically.

4️⃣ Upload Production code to server

5️⃣ Configure the server, hosting provider

----Adding Lazy Loading----
	  (Optimization)

Lazy Loading - Load only when it's needed.

- Comment the import statements, import it laziliy

import() -> import dynamically when needed returns promise 

	import('path_to_that_file')
	.then(module => {can be executed functions whenever and whereever needed});

<Suspense></Suspense>:
- Import it from REACT
- <Suspense> lets you display a fallback until its children have finished loading.

Example: 
<Suspense fallback={<Loading />}>
  <Albums />
</Suspense>

lazy(): 
- Call lazy outside your components to declare a lazy-loaded React component.

- lazy lets you defer loading component’s code until it is rendered for the first time.

Example: 
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));

-----Building the Code for Production----------

The code we wrote is not the one we are or going to upload (Its only for development).

For creating a production build we need to run:
	> npm run build
-> This will produce a code bundle with highly optimized and transformed code which is ready to be uploaded.
-> after the command is finished, it will create a build folder,
	build
	 -> static
	     -> css
		 -> js

build folder is the folder that should be deployed to a server.

js folder has all the necessary code that you wrote and all the third party packages that you are using including the react library itself.

-------Deployment---------
A React SPA (single page application) is a static Website, consists of only HTML,CSS,JS only.

Therefore, A Static site Host is Needed
 -> Netlify, Firebase Hosting
Search to Google: deploy static site

------Configuring Server: Server side vs Client side routing------

> Configure as SPA?
  
  Server Side Routing vs Client Side Routing


(/some-route)---Server--(Production-Ready React Code)---
	|												   |
	|												   |
 (Request)										   (Response)
	|										[HTML,CSS,JS (React-Code)]
	|												   |
	|-----------Client-----------------------------(/some-route)


IMPORTANT! : ⚠️
when you have your application deployed on a server and a user enters a URL in the browser, what happens technically is that the browser sends a request to the server. The server then sends back a response, which of course, is in the end is this React application. So the HTML file, but also the JavaScript code that makes up this application. Now if we did not just send a request to main domain, but maybe also to some path like /posts or whatever path we have on our website, then that path also reaches the server on this initial request. And by default, the server would try to find the fitting response  for the path we requested in our request. For example, by searching for a folder with a name of some route. And of course, the server in this case would fail to find a fitting file because it doesn't have any server side logic for handling requests with different paths. What the server should instead do is always return
exactly the same HTML file and the same JavaScript code so that this path, which we requested, can be resolved on the client side by that JavaScript code we requested, so by our React app that's using React Router.

However, as mentioned, the default behavior is not that the server always returns the same file. Instead by default, it would look for a fitting file in a fitting folder based on the request we sent.
And that's why we got this question whether we want to configure this as a single page application. By answering this question with yes,
We configure the hosting site as to host it as a Single Page Application.

IMPORTANT! : ⚠️
When the hosting providers not ask you whether you want to configure the app as a single page application. In such cases, you manually must set up some redirection rule that basically forwards all requests to index.html (root-page).


