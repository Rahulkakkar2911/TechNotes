----------------------------REACT JS---------------------------

----------Section 1: Getting Startedüéâüéä----------
React is a javascript library for building USER INTERFACES.
like
- NETFLIX

Here Mobile Apps and Desktop Apps feel very "Reactive": Things happen instantly, you don't wait for new pages to load or actions to start.
Traditionally, in web apps, you click a link and wait for a new page to load. You click a button and wait for some action to complete.
	
	client ----------> Server
		 <----------

It is a client Side Javascript Library
All about building modern reactive interfaces for the web
Declarative,  

NORMAL VANILLA -> IMPERITIVE CODING PRACTICE -> LOW LEVEL CODE (DRY VIOLATED)

BUILDING SPAs (Singel Page Applications):
 - React can be used to control parts of HTML pages or Entire Pages.
	- "Widget" approach on a multi-page application. Some Pages are still rendered on and served by a backend server.

 - React can also be used to control the entire frontend of a web application.
	- Single-Page-Application (SPA) approach. Server only sends one HTML page, thereafter , React takes over and controls the UI.
	- Smoother UI and Better UX.
	- (NETFLIX)

-----------------------REACT ALTERNATIVES-----------------------

- REACT.js is a LEAN AND FOCUSED component based UI library. Certain features (eg. ROUTING) are added via community packages. 

- Angular.js is a Complete component-based UI framework, packed with features. Uses TypeScript. Can be Overkill for smaller projects.

- Vue.js is a Component-Based UI framework, includes most care features. A bit less popular than React & Angular.


-------------Exports and Imports--------------

*PERSON.js*

const person = {
	name:"max"	
}

export default person

HERE default keyword means that we just import something from that file

*UTITLITY.js*

Exporting Named Stuff ->
export const clean = () => {...}
export const baseData = 10;

*APP.js*


IMPORTS AND EXPORTS READ.

import person from './person.js'
import prs from './person.js'

//importing named stuff
import {baseData} from './utility.js'
import {clean} from './utility.js'

----------Section 3: React Basics & working with components‚ùìüî®-----------

----------------------Components-------------------
React makes building complex, interactive and reactive user interfaces simpler
React is all about "Components"

Why component and what is it? 
All UIs are built by the components -> building blocks
1. Reusability! -> DRY
2. Seperation of Concerns! -> Don't do too many things in one and the same place (function)
 			(-> Split big chunks of code into one and the same place <-)

How is a "Component" Built?
			HTML + CSS + JS => Components
			Components..... => UI

React allows you to create these (re-usable and reactive) components consisting of HTML and JavaScript and CSS.

React uses a declarative approach to built these components.
 - Define the desired target state(s) and let react figure out the actual javascript DOM instructions.
Here you wont write any dom updating events, with react and its components -> ITS MAGIC
					  BUILD YOUR OWN custom HTML Elements

--------Creating first Projectüçæ-----------
for full docs -> visit create-react-app.dev
Prerequisites : NODE JS must be installed

TO create a REACT project: 

1.	$>: npx create-react-app <APP_NAME>

It will create a subfolder named as <APP_NAME> and switching to that with CD command -> 

2.	$>: cd <APP_NAME>

Then run this command to run a script that will start a local development server at port 3000 and this server will watch your code files (src), if there is any change, it will automatically update the loaded page in browser.

3.	$> npm start

By running this command, it creates preconfigured folders with some basic REACT code files and a bunch of configuration files which will help you to build that react app for production use -> a couple of transformation and optimization steps between developing any REACT App.

The Created folder contains alot of files and folders:
1. package.json -> holds all the dependencies (react + other dev dependencies)
2. SRC folder -> contains all the source code on which we will be working on.

Command to install all the dependencies -> (packg.json)

4.	> npm install

-> creates a node_modules folder -> holds all the packages that get install with above command.


Inside that directory, you can run several commands:

  npm start
   - Starts the development server.

  npm run build
   - Bundles the app into static files for production.

  npm test
   - Starts the test runner.

  npm run eject
   - Removes this tool and copies build dependencies, configuration files and scripts into the app directory. If you do this, you can‚Äôt go back!

We suggest that you begin by typing:

	> cd my_first_app
	> npm start


------Analysing a Standard React ProjectüèÉ‚Äç‚ôÇÔ∏è------

'src' folder is the one on which we will spend majority of our time.

'src'

 -> index.js -> this is the first code file which will be executed whenever you visit the site or basically localhost:3000 to be particular. (not exactly it will be run, but it is the starting point and before running on browsers it will be tranformed in a browser friendly version of code, as some features wont work in NORMAL JS but will work after transformation)
		 -> in this file, we import ReactDOM object from react-dom third party library, which is one of our dependencies. (Basically react is split into 2 packages : REACT and REACTDOM)

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

 -> App.js -> Contains a function named App and we then export this function and inside this function we return some HTML code which wrapped inside (parenthesis) (not regularly see, not a valid JS code) -> this is a JSX (special feature invented by the react team and it works in JS files because of the transformation steps SRC -> PUBLIC (index.html));


'public'
 -> index.html -> this is basically the only HTML file that is being used by the overall REACT application as it's a SPA.
		   -> It is the only entry point, the place where the React-Driven UI should be rendered. NOTE: In this index.html -> regular HTML DOCUMENT STRUCTURE, and if we look at the body, you will find a DIV with ID : 'root'. That's the div where we inject or attach our react-driven UI. (doesn't hold any content initially)

		   This is the root that we select in index.JS to render it, we tell react to make it root. The main place where the React app gets rendered. Then we store this root object in a variable and on that object we call render() to tell react what should be rendered in that DIV. Content inside that div should be replaced by what inside the render method-> above ex: <App />


So what is this <App />: -> 
	import App from './App';
	 - App is the component (FIRST COMPONENT) which is get rendered in the place of that element with the id of root.
	 - Root component as its the main component that will get rendered in index.js file
	 - <App /> -> Its not a regular JS syntax -> called as JSX

	
----------JSX----------
JSX -> JAVASCRIPT AND XML (HTML == XML) and it works in JS files as because of the npm start process running the code get transformed to more browser-friendly code before everything is being served.


In older React Projects you need to (import React from 'react') in all your components files, to be precise you need it where you write JSX code.

JSX code is just Syntactic Sugar under the hood its actually transformed to methods called on the React Object. That's why we need to import it in the past.

 -> return React.createElement() -> is called when we create JSX, this function takes 3 arguments:
	1. Element which should be created (in string if built-in), if custom-component then point at the import name which is at above of the file and without string.
	2. Object that has attributes to above specified Element
	3. Content between opening and closing tags (elements or anything)
 
In previous versions the following JSX the code Which is this:
	return(
		<div>
			<h2> Let's get Started! </h2>
			<ExpenseItems items = {expenses}/>
		</div>
	);

 - will look like this:

	return React.createElement(
		'div',
		{},
		React.createElement('h2', {}, "Let's get Started!"),
		React.createElement(ExpenseItems, {items: expenses})
	);

That's why we need to wrap the JSX code in wrapping Div, as we can't write without wrapper in older codes, because we can't return more than 2 things.

-----------Building our components-------------
It is a good practice to actually putting these new components into new files so that you have one file per component.

IN THE 
	->SRC folder add
		-> COMPONENTS FOLDER
			-> here add the components source file (js and css)

NOTE : Don't move App.js as it is a special kind of component, you can move it but its not considered generally.

With react we build a Component tree as components will get nested sometimes inside one another. You have the app component at the top and other nested inside it.
	
			<App/>
			/	\
		     /	 \    
		<Header>   <Tasks/>     (For example)
				/  |	\
			     /   |   \
			    /    |    \
			   /     |     \
			<Task/> <Task\> <Task\>

Here Only the top most i.e <App/> is rendered into single HTML Page. All The other components will not be rendered with this React.Render() instruction. They will be used as regular HTML elements inside of our <App/> component.

--------------How is a Component Written in REACT?----------------

Its just a Javascript Function (Special Kind of function), special due to its return structure.

1Ô∏è‚É£We need to create a filename by name of the Component (inside src Folder ) AS (ComponentName.js, Naming convention <3 ONLY)
 
2Ô∏è‚É£Inside it write a normal function as:
	
	function ComponentName(){
		return (
		 // JSX - CODE
		);
	}

3Ô∏è‚É£To use it we need to export it. otherwise it will be usable only in that file only.
	
	export default ComponentName;

4Ô∏è‚É£We can import it in any file where we need to render it.

	import ComponentName from './components/ComponentName'; 

(JS knows that it will be js file as it will first search a js file named 'ComponentName');

5Ô∏è‚É£To use it after importing
	<ComponentName></ComponentName> 
		(In the JSX-CODE)

NOTE: 1. (IMPORTANT!) Its important to name the component starting with a capital letter as REACT distinguish between custom_components and inbuilt HTML ELEMENTS
	2. You MUST have 1 ROOT ELEMENT / RETURN STATEMENT (WorkAround is Wrap the whole thing inside 1 DIV)

If the componenet don't have content in between like here -> 
<ComponentName>HERE!</ComponentName> 
you can write it as a Single closed tag -> (just like hr, br, img etc);
<ComponentName/>

-----------Adding Basic Styling to Components------------
 -> CSS files are added next to the component file in the SRC folder
 -> ComponentName.css -> filename
 -> import that file into the ComponentName for which you wrote that CSS code.
		By importing that You are telling the build process to consider the file as well;

NOTE : class = className (Regular HTML vs JSX)

--------------------Dynamic Data-------------------
To Enter data that you get from anywhere before return the JSX,
You can add data in curly braces {} (variable)

 -> Dynamic Placeholders

So between these curly braces you can run basic javascript expression.

				<h2> {1 + 3} </h2>

----------------------Props-----------------------
We can make our components reusable, by using parameters and a concept called PROPS in react.

We can pass data from a parent component to its child components.

Props are arguments passed into React components. Props are passed to components via HTML attributes.

Pass Data into our components and adding new data

EG: 	function Car(props) {
  		return <h2>I am a { props.brand }!</h2>;
	}

	function Garage() {
  		return (
    			<>
      		<h1>Who lives in my garage?</h1>
      		<Car brand="Ford" />
    			</>
  		);
	}

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(<Garage />);

If you have a variable to send, and not a string as in the example above, you just put the variable name inside curly brackets {}

Note: React Props are read-only! You will get an error if you try to change their value.
 
To utilize the props add them into the function parameter, and use the attributes which were passed to that element. (eg: props.name , props.car etc.)

-------------- Splitting Components---------------
Every Component is focused on one task (that can't be broken into more simpler code), and thats why react is component focused we can assign the component a task.

----------------Composition----------------
Building a UI from small components piece by piece is called as Composition.

Note: You can't use your custom components as wrappers around other kind of content (having content between opening and closing tags doesnt work for custom components as it work for built in html elements), let's say you want an custom component like <div> so that you can hold elements, so by doing nothing it will not show anything  inside that and for that to we work we have one special prop that is built in the react (To build resuable wrapper components)
   
	props.children
	
for example: 
    <div>{props.children}</div>

{props.children} -> PlaceHolder for the content that is inside the component or we can use this inside a wrapper div

IMPORTANT! : ‚ö†Ô∏è
Only default HTML tags support 'className', not the custom components, we can dynamically add classes to the custom components

------------------Organizing Component Files---------------------

We can create subfolders in SRC/COMPONENTS folder for components that deals with a particular function and further reduce the complexity of number of files.

EXPENSES subfolder for - Expense Related stuff
 - all the files related to expense stuff

UI subfolder for - General UI Stuff
 - CARD
 .....etc
----------Section 4: React State & Working with Eventsüôé‚Äç‚ôÇÔ∏èüß®------------


-----How We can Reaect to User Events and How such events can TRIGGER State Change?--------------

Events like (Button Click)
For all these default events,there is a prop equivalent in React, which we can add to these built-in HTML elements to listen to these events.

So instead of adding a listener as we would normally do it, (By Selecting the element and then adding a event listener to it), Instead in React we Add an Event Listener by going to the JSX element and there we add a special prop which Starts with ->
onEventName: EX: onClick
- It Adds an Event Listener for that specific Event, to that prop or attribute we assign a value -> Function();

- This function can be an anonymous function which is wriiten like Ex.2
- Its a Good Practice to write the function before returning the JSX
- Just add the refeerence in the OnEvent value, Don't Execute it
- Remember its necesaary by the elements to support that event which you are adding.

- Name your functions like this in Ex.1, Convention to follow, End with Handler start with name of the event.

Ex1:
<Button onClick = {clickHandler}></Button>

Ex2: <Button onClick = {() => {console.log("Clicked!!!")}}></Button>

------How Component Function are Executed?------

Problem : If you write a click handler and change a value in that function for a variable which is used by the returned JS and is Passed by the parent of the Current Component -> IT DOES'NT CHANGE!

But, Why? 
-> Because, REACT does'nt work like this.
Lets see how React Parses the JSX CODE and how it considers and how it Brings it on the screen.

Component is just a regular function, the only special thing about that function, is that it returns JSX. Now since it's a function, someone has to call it, and major thing to notice that we never called our component function.
Instead we just use these functions like HTML ELEMENTS in the JSX Code.

Under the hood this is almost (above) like a function call. By using our components in JSX code, We make React aware of our component functions.

Whenever react evaluates this JSX code, it will call these component functions and these component functions stand to return JSX code, which is first of all evaluated, up until there's no more JSX code to be evaluated. So react keeps on calling any component functions it encounters in JSX, then calls any functions that those functions might have returned so any elements those components might have used in their JSX code until there are no more functions left.
Then it re-evaluates the overall result and translates that into DOM instructions which renders something like this on the screen. That's how react works.

It's all started by the index.js file, Where we initially point at App component, That's the first component function which is being called and that happens when the react app is been loaded on the screen which happens when the page is been visited.

Example:
REFER REACT-DEV/Expense_Tracker
So in the case of ExpenseItems.js, if react encounters this expense item, it calls this ExpenseItem component function, executes all the code in there, encounters this JSX code and calls this Card function and the ExpenseDate function and then it goes through the JSX code of this components until there's no more component code left to call and then translates that into DOM instructions which renders.

Problem with that is, that react never repeats that React goes through all of that when the application is initially rendered, but thereafter it's done. However in modern applications, of course you sometimes want to update what's visible on the screen, for example because a button was clicked and that button should change some text which is being output. So we need a way of telling react that something changed and that a certain component should be re-evaluated and that's where react introduces a special concept called state.

-------------State-------------
By default, Regular variables are not triggering the re-evaluation of the Component

But if it would revaluated then it gets triggered and the regular varaible can be used to change the JSX or component code.

So To Tell REACT that it should run it again, we need to import something from REACT LIBRARY

1Ô∏è‚É£Importing a function called as useState().

	// named import in curly braces {}
      import REACT, {useState} from 'react';

useState() -> function provided by the react library and this function allows us to define values as state where changes to these values should reflect in the component function being called again.

It is a React Hook, and all these REACT HOOKS can be recognized by the fact that they start with word 'use' in their name.

 - useState wants a default state value, because with useState we basically create a special kind of variable. A variable where changes will lead the component function to be called again and we can therefore assign an initial value for that special variable (INITIALIZATION) and we pass this initial value as a paramter to useState()
 
 - This useState() returns something, It gives us access to this special variable, however it not just only return that access BUT also it returns a function that we can then call to assign a new value to that variable.

 - useState() actually returns an array, Where the first value is the variable itself, the second value is that updating function, we can call this function to set that variable.

IMPORTANT! : ‚ö†Ô∏è
 - HOOKS must be called inside the component function and they can't be called outside the component function and not in any nested function inside the component function. (1 Exception is there)
 - we can only do it inside the component function
For Example: 

	const ExpenseItem = (props) => {
       	const [title, setTitle] = useState(props.title);
	}

- "title" is the value that we can use in JSX CODE
- New Value is assigned by the "setTitle" function, pass a new value to this function, and calling this function does'nt only assign a new value to the variable, but its managed by REACT somewhere in memory and we call this state updating function.

- The special variable will not just recieve a new value but the component function in which you called this state updating function will be executed again.

(That is what we need, we want to call the component function again when our state changes), by calling this state updating function, you're telling REACT that you wanna assign a new value to this state and that then tell REACT that the component in which this state was registered with useState should be re-evaluated. And therefore React will go ahead and execute this component function again.

 - This state updating function actually doesn't change the value right away, but instead "schedules this state update". So, its not available rightaway.
If you have data, which might change, and where changes to that data should be reflected on the user interface then you need state because a regular variables will not do the trick with state, however you can set and change values and when they do change, React will re-evaluate the component in which the state was registered and only that component, by the way not any other components, just this component in which this state was registered.

---------Closer Look at useState()-----------
"useState" registers some State, So some value as a state for the component in which it is being called and To be more precise here, It registers it for a specific component instance (every instance got its own slice for useState).

For Example:
In REACT-DEV/ExpenseTracker, we have used expenseItem component 3 times. Now every component item recieves its own seperate State which is detached from other states. We have 1 function defination of the component, but we are calling it 3 times and every time it's called, a new separate State is created of course in the same way, but managed independently by React. If the state of one indiviuals changes , others remain intact. So, We have seperate states, even if we create a component more than once. (CRUICAL and GOOD to have). 

If you add a console.log() in a component function itself, this will be called whenever the component function is being executed.

Short Summary of above:
 - State really is seperated on a per component instance basis

	const [title,setTitle] = useState(props.title)

- By calling useState, we tell react that it should manage some value for us. We never see that variable itself. So we therefore just call a function. we don't assign a new value to the variable again.
How it gets the new VALUE? -> Every time we call the update function, component code executed again with new value for the variable, React will not reinitialize the State. Instead, it will detect that this State had been initialized in the past, and it will just grab the latest State which is based on some State update(we always get a brand new snapshot).

The State adds reactivity to our application, Without state our UI would never change. But with State and with listening to events, we can make sure that we can react to user input and that such input can result in a visible change on our screen.

-----------Working with Multiple States----------------
	OR   Using useState in 1 component more than once

APPROACH #1:
You can call useState more than once. You can have multiple States, multiple States slices or State pieces per component, All of these States inside of one and the same component will then also be totally separated from each other.

There is also an alternative and it depends on personal preferences, which approach you Prefer.

APPROACH #2: CASE 1
You can pass in an object as a value if you need states for dependent component.
But difference is that you need to update all three of them at once and while updating make sure that no values get lost while updating

 - Both Approaches are fine.

-------Updating States based on the previous states-------
APPROACH 2: CASE 2
Whenever this condition arrives, pass a function to the Value Updating Function of the useState variable. This function will automatically be executed by REACT and it will recieve previous state snapshot for that state in which you are calling the updating function. And in that function you should return new state snapshot.


	setUserInput((prevState) => {
            return {
                ...prevState, 
                enteredTitle: e.target.value
            }
        });

In Many cases APPROACH 2 : BOTH CASES will work fine but the thing that should be kept in mind is that REACT SCHEDULES STATE UPDATES, IT DOES'NT PERFORM IT INSTANTLY. 
But the difference in both cases of APPROACH 2 is that in CASE 1 it does'nt guarantee that REACT will give you new snapshot ALWAYS, BUT in CASE 2 it guarantees.

SO IN SUMMARY:
 - Whenever your state update depends on previous state, use function syntax.

----------------CHILD TO PARENT COMMUNICATIONS----------------
EVENT PROPS: 
We can create our own EVENT PROPS which expects functions as values and that would allow us to pass a function from a parent component to a child component and then call that function inside of the child component and when we then call a function, we can of course pass data to that function as a parameter and that's how we can communicate up from CHILD TO PARENT.

NOTE: We can't skip components in between or intermediate components from CHILD to PARENT

---------------Lifting State Up------------------
				<App/>
				/    \
			     /      \
                <Expenses/>  <NewExpense/>

Consider the Tree -> 
Here the NewExpense generates some data i.e NEW EXPENSE (DATA/STATE is generated in this component), Now it is quite common that you do generate or fetch data in a component but that you might not need that data in that component.

let's say you need the data in Expenses component, So naturally we would like to hand that data over but that doesn't work like this because we have no direct connection between two sibling components.

By Now We can only communicate from PARENT to CHILD and CHILD to PARENT.

The app component in our application has access to both the new expense and the expenses component because it renders both components in its returned JSX code, that's why we wanna utilize that. Because we can now store our state in that closest involved component. So in that parent component which has access to both involved components by lifting our state up. So by passing our generated state data from the new expense to the app component. So by passing our generated state data from the new expense to the app component.

-----Controlled and Uncontrolled Components-------

Controlled Components -> Whenever you use 2 way binding, you are controlling a component 
Value and changes are not handled in the components itself, but in the parent component.

Presentational components vs Statefull components,
stateless versus statefull components or dumb vs smart components
It simply means that in react app you will have couple of components which manages some state (statefull components), and some components which don't manages some state (stateless components AKA presentational or DUMB component because it doesn't have any internal state it's just there to output some data.)

----------Section 4: Rendering Lists and Conditional ContentüìÉ------------

---------Rendering Lists of Data------------

When we got a bunch of objects into an array full of Component elements (JSX code), because if you do output an array of JSX elements here, like a couple of cards, then React is capable of simply rendering these elements.

an array of JSX elements as part of your JSX code, react would simply render these elements side by side, and that's what we utilize here to transform our array of objects into such an array of JSX ELEMENTS or COMPONENTS, which then are rendered by React.

So, The REACT Renders the Array elements as ->

	[<ExpenseItem/>, <ExpenseItem/>, <ExpenseItem/>]

				=	=
	<ExpenseItem/>
	<ExpenseItem/>
	<ExpenseItem/>

				=	=

	  <ExpenseItem/>  <ExpenseItem/>  <ExpenseItem/>

---------------Understanding Keys!------------------

NOTE: Whenever you get this warning! -> 
"Each child in a list should have a unique "key" prop."

It is Because React see some items almost similar inside a DIV (which is using some state variable to update the componented, when we add a new item in that DIV BLOCK
)
React renders this new item as the last item in this list of div's and updates all items and replace their content, such that it again matches the order of the items in my Array and this is not great. This is happening because to React, All these items look similar and it only sees that my Array changed that it's now longer than before and hence it simply renders an additional div and it adds that at the end and then it simply walks through all the items and updates the content inside of every item to match the Array content again.

The final result, therefore is correct here but from a performance perspective this is not great because all items are visited and updated and it can even lead to bugs. (statechanges could be lost inside component which was inside that array due to overwritten of the component)

Why REACT behave like this? -> Because it has no other way  

It currently simply checks the length of the Array and then has a look at the number of items that were already rendered. The individual items all look similar to React though so it can't know where a new item should be added. That's why we get this warning

IMPORTANT! : ‚ö†Ô∏è
We have a way of telling react where a new item it should be added and we do that by going to the place where we output our list of items. We add a special prop to that item there (Key), it will help REACT to identify indiviual items (key should be a unique ID) (You can also use, index item (available in MAP as second argument) for special key).

------------------Conditional Content--------------------
We can't use long statements or flow EG: FOR , IF ELSE etc inside {}, But we can use ternary operator inside {}.
	{Condition ? true_do_this : false_do_this}

We can also use Short-Circuiting && and ||

IMPORTANT! : ‚ö†Ô∏è
We can store JSX content in variables. we can check before hand the content and then later return that.

We can have multiple return statements (returning JS) for multiple different renderings according to the condition and use-case

----------------Adding Dynamic Styles-----------------
You can use "style" prop on the element which expects a JS Object as a value. There you can provide styles like width, height etc as key's and its values as value.

if you want CSS style names (seperated with dashes) you need to have them as keys in STRING
Else You can use camelCasing 
		Ex:
			style={
					{
                    			height:'8%',
                				'background-color':'red'
					}
			};

----------Section 4: Styling React Componentsüëñüëï------------

----Setting Dynamic Inline Styles----

We can add styles based on states of the component, by using ternary operator

For Example: 
<label style={{color:isValid ? 'black':'red'}}>Course Goal</label>
<input style={{borderColor:isValid?'black':'red', background:isValid ? 'black': 'salmon'}} type="text"/>

Here, we know this inline styles has the highest priority, therefore we don't want to set it like that (always)

----Setting Classes Dynamically----

We can add Classes to the elements dynamically, by again using ternary operator depending upon the state of the component and use case
Example:
	<div className={`form-control ${!isValid ? 'invalid' : ''}`}>
			here isValid is the state of the component

IMPORTANT! : ‚ö†Ô∏è
This is not scoped to that component (It applies the rules to global codebase), that's why we dont prefer to use it, Only thing is that you need to be carefull, while using it.
There are problems with this approach of spilling styles to other components.

-----Styled Components-----
1 Way to avoid above problem, It is a package, It helps to build components that have certain style attached to them

				https://styled-components.com/

‚úÖTo get started, we need to install it using:
	npm install --save styled-components

‚úÖYou need to import ->
	import styled from 'styled-components';


When the styled component is rendered, class names on that component are dynamically generated by the styled components package Because what this package does in the end is it looks at the styles we set up here and then it wraps these styles into generated class names where it guarantees that every class name is unique, so that it can't spill over to other components of the app.

But now since we have unique class names for every styled component, the style set up here will never be able to affect the number of component in the app because these unique class names are really well unique per style component.

- It provides a method which will return a styled component
- This styled package have methods for all HTML elements
- Dont need to provide any selector in between as these styles will directly applied to the component

Example: 


//This syntax is called 'tagged template literal'
	
const Button = styled.button`
  font: inherit;
  padding: 0.5rem 1.5rem;
  border: 1px solid #8b005d;
  color: white;
  background: #8b005d;
  box-shadow: 0 0 4px rgba(0, 0, 0, 0.26);
  cursor: pointer;

&:focus {
  outline: none;
}

&:hover,
&:active {
  background: #ac0e77;
  border-color: #ac0e77;
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.26);
}

`;

export default Button;

----Styled Componenets & Dynamic Props----

The styled components, so the components returned by these styled components functions, forward all props you set on them to the underlying component.
We can use Props in the styled components where we can specify what we need to add.
we can write props in tagged template literal as 

Example : 
	
	// Here we are adding a text dynamically by the props which are fed to the styled component 

	<FormControl invalid = {!isValid}>
        <label >Course Goal</label>
        <input type="text" onChange={goalInputChangeHandler} />
      </FormControl>

	& input {
  		display: block;
  		width: 100%;		// This function is called by the styled component function 
  		border: 1px solid ${props => props.invalid ? 'red' : '#ccc'};
		background: ${props => props.invalid ? '#ffd7d7' : 'transparent'}
  		font: inherit;
  		line-height: 1.5rem;
  		padding: 0 0.25rem;
	}

----Styled Componenets & Media Queries----
You have to write direct media queries that we write earlier in the tagged template literal as shown below:

- This will only affect that component only
Example: 
	const FormControl = styled.div`

		@media (min-width:768px){
  			width: auto;
		}
	
	`;

----Using CSS Modules----
‚úÖTo use this feature you need to create a css file as follow-up:

			filename.module.css

‚úÖImporting the module
import styles from './Button.module.css'

This "styles" is an object which have all the classes defined in the module as its properties

‚úÖYou can apply the classes as following:

Here styles is the previous object on which we have the classes defined: 
		styles.button,......etc

<button type={props.type} className={styles.button} onClick = {props.onClick}>
      {props.children}
    </button>

In the dev tools, you will see different class is written on that component, But it is: ->
	class = "ComponentName_ClassName_SomeHash"

It does this to make it unique

- CSS Modules concept ensures that the CSS styles we set up in a CSS file are a scoped to the component we import this file into

This is actually the best method to use CSS, having our styles set up in CSS files but there's still scoped to components where we use them.

----Dynamic Styles and Media Queries with CSS Modules----
We can add dynamic classes as normal classes 
using template literal
for media queries we just need to add those in the module.css as normal media queries, and since we are specifying the class on the component therefore we dont need to do much else.

-----------Section 7: Debugging React Appsüõ†Ô∏è-------------

Understand the error, where it is coming from from the console. then try to understand why it is coming.

If its a logical error then use breakpoints on the src files from the developer console in the browser.
	‚úÖGo To -> Sources -> Then from the sidebar check you will see your original code files -> select the file from where you want to stop execution and put the breakpoint on the line from where you want you check (by clicking on the line number).
	‚úÖUse the controls and walk through the code step by step.

			----Using React DevTools----
Its a Browser Extension that can downloaded from here:

https://chrome.google.com/webstore/detail/react-developer-tools

After downloading you will get 2 tabs in Chrome Devtools:
	- Components
		- We can see a component tree by clicking this
		- we can see props of a component once we click a component
		- we can see which components render this current component
		- search for a component
		- We can also see hooks attached to a component, change the hooks (particulary state hook)

	- Profiler
		- The Profiler tab allows you to record performance information.

------Section 9: Working with Fragments, Refs etc.üß®---------

			------JSX LIMITATION-------
If we have adjacent root level JSX elements like in this example:
	return (
		<h2>Hi there!</h2>
		<p>This Does not work :-(</p>
	)
we'll get an error.

In REACT, You can't return more than one "root" JSX element (you also can't store more than one "root" JSX element in a variable).

Reason for this is: 
	return (
		React.createElement('h2', {}, 'Hi there!')
		React.createElement('p', {}, 'This does not work :-( ')
	
	);

You can't return more than 1 statements 

1 Workaround for it is:
	-> To simply wrap around the adjascent elements with a element.
	-> You have only 1 value to return 
	-> this could lead to a Problem named: "<div> Soup"
		
		<div>
		  <div>
		    <div>
                  <div>
			  <h2> Hello </h2>
			</div>
		    </div>
		  </div>
		</div>
	-> In bigger apps, you can easily end up with tons of unnecessary <div>s (or other elements) which could add no semantic meaning or structure to the page but are only there because of React's/ JSX' Requirement.
	-> Application can be slower

Alternative for it is:
	-> You can simply use a native JS array, you can put the adjacent elements seperated by commas
	-> We can return an array because React is able to work with arrays of JSX elements.
	-> You will get a warning because whenever you're working with an array of JSX elements, React wants a key on every element and with no exception here

Solution:
	We can use a "Wrapper Component"
		inside of it just return props.children
	->It is a Empty Component!
It's an element which won't render anything to the dom, but the requirement is met that there must be one root component

‚úÖIt's a good practice to create these types of components under Helpers Folder/Directory

Example: 
	
	const Wrapper = props => {
		return props.children
	}

	export default Wrapper;


-----React Fragments-----

‚úÖimport React, {Fragment} from 'react';

return (
	<React.Fragment>
	   <h2>Hi!</h2>
	   <p>This does'nt works</p>
	</React.Fragment>
)

	OR

return (
	<>
	  <h2>Hi!</h2>
	  <p>This does'nt works</p>
	</>
)

Its an empty wrapper component: It doesn't render any real HTML element to the DOM. But it fulfills React's/JSX' Requirement.


----React Portals----
Portals provide a first-class way to render children into a DOM node that exists outside the DOM hierarchy of the parent component.
Like Modals, Which needs to be direct child of the body or root element

‚úÖFor this, You create a Portal for the elements inside PUBLIC -> index.html -> Body ke niche 
	<div id = "backdrop-root"></div>
	<div id = "overlay-root"></div>
	<div id = "root"></div>

In the modal file, 
Create -> 
	before the Modal component function,

const Backdrop = props => {
	return (div which has backdrop class)
     EX: <div className = {classes.backdrop} onClick = {props.onConfirm}></div>
}

const ModalOverlay = props => {
	return (div which modal class)
	(Card of the Modal with its children, text button etc.)
}

On the main component add an expression  in which we need to add something.

 import ReactDOM from 'react-dom';

return (
	<>
		// This line ports the element (first argument) to the container element which is the second argument of the createPortal function.

	  {ReactDOM.createPortal(React node that should be render in JSX ,  pointer to that container where this previous node shoud be render we need to select that element by DOM API (document.getElement......))}
	</>
)


In JSX it should remain there where you want to render (in that particular component) but in reality it will ported to where it is mentioned (second argument) 

------------------------------Ref's (References)-----------------------------------

Refs provide a way to access DOM nodes or React elements created in the render method.
In the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.

‚úÖThere are a few good use cases for refs:

 - Managing focus, text selection, or media playback.
 - Triggering imperative animations.
 - Integrating with third-party DOM libraries.

Avoid using refs for anything that can be done declaratively.

For example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it.

‚ö†Ô∏èDon‚Äôt Overuse Refs
Your first inclination may be to use refs to ‚Äúmake things happen‚Äù in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to ‚Äúown‚Äù that state is at a higher level in the hierarchy.


‚úÖTo Create a Ref we need to import a hook ->

‚ö†Ô∏èOnly usable inside of functional components
	import React, {useRef} from 'react';

It takes a default value you wanna initialize it to (by default undefined).
	const variable_name = useRef();

‚úÖYou can connect this ref to any Component or any HTML element by adding a "prop" to that element named "ref"
(just like "key" prop), However it is very often done for Input elements.

‚úÖNow to that ref prop pass that variable_name which you earlier created

Example:
	const nameInputRef = useRef();

	return (
		<input ref = {nameInputRef}>
	);

	--Working of Ref--
Accod to above code, a connection will be established. The first time React reaches this code and renders this code, it will actually set the values stored in nameInputRef to the native DOM element that is rendered based on this input.

This ref value, which is being generated here always is an object, which always has a current prop and the current prop holds the actual value that ref is connected with Now, by default, it's undefined but as soon as this code ran, because of this ref prop, the nameInputRef is connected to that input and hence, it's actually the input which is being stored as a value in the current prop and what's being stored here really is the actual DOM node. So not some theoretical value or anything like that but the real DOM node,

Now, it is recommended that you don't manipulate it. Your DOM should really only be manipulated by React. But reading data from the input doesn't sound too bad because you're not changing anything with that.
 

‚ùìWhich is Better Ref's or State?

The question is whether refs or state is better. You can use either of the two. You will sometimes have use cases where you just want to quickly read a value, for example.

And if you only want to read a value and you never plan on changing anything, well, then you don't really need state because just to use state as a keylogger is not that great, It's a lot of unnecessary code and work. So if you just want to read a value, refs are probably better. In scenarios like this, it's up to you what you prefer. Refs, which are a little bit less code but you have this edge case of manipulating the DOM, or a state, which is definitely cleaner but is a bit more code.

--------Controlled Vs Uncontrolled Components--------

‚úÖUncontrolled Components: Uncontrolled Components are the components that are not controlled by the React state and are handled by the DOM (Document Object Model). So, In order to access any value that has been entered we take the help of refs.

For instance, if we want to add a file as an input, this cannot be controlled as this depends on the browser so this is an example of an uncontrolled input.

 - Components are under the control of DOM.
 - Are Uncontrolled because during the life cycle methods the data may loss
 - Internal state is maintained
 - We access the values using refs
 - Controlled by the DOM itself
 - Has very limited control over form values and data

‚úÖControlled Components: In React, Controlled Components are those in which form‚Äôs data is handled by the component‚Äôs state. It takes its current value through props and makes changes through callbacks like onClick, onChange, etc. A parent component manages its own state and passes the new values as props to the controlled component.

Example: We are creating a simple form that comprises an input field with a label name and a submit button. We are creating an onSubmit function that triggers when we submit the form which shows the name that we have filled in the alert box.

 - The component is under control of the component‚Äôs state
 - These components are predictable as are controlled by the state of the component
 - Internal state is not maintained
 - It accepts the current value as props
 - Controlled by the parent component
 - Have better control on the form data and values

--------------Section 10: Advanced: Handling side effects, Using Reducers and Contextüë®----------------

--------What is an "Effect" Or a "Side Effect"---------

React library itself has one main job, 

 - to render the UI,

 - to React to our user input,
 
 - Evaluate & Render JSX
 
 - Manage State & Props
 
 - React to (User) Events & Input

 - Re-evaluate Component upon State and Prop Changes 

Side effects are everything else that might be happening in your application and a good example here is sending a Http request or storing something in browser storage.For example, Local Storage, But you could also think about timers or intervals which you set in your code.

These are all tasks which you of course often have to consider in your application but these tasks are all not related to bringing something onto the screen, at least not directly.

These are therefore tasks which must happen outside of the normal component evaluation and render cycle - especially since they might block/delay rendering (e.g Http Requests).

You would even create an infinite loop Because you would send the request whenever the Component function re-runs and in response to the request you change some state which triggers this function again. So therefore such side effects should not go directly into this component function because that would most likely create bugs, infinite loops or simply send too many Http requests to stick with that example.

Therefore we'll have a better tool for handling side effects and that's a special React Hook which we can use. (The useEffect Hook)

---------useEffect() Hookü™ù---------

	useEffect(() => { .. }, [ dependencies ]);

The useEffect() Hook is simply another built in Hook which you can write inside the component function.

1Ô∏è‚É£ Argument : A function that should be executed AFTER every component evalutaion if the specified dependencies changed.
In this function, we can perform our side effects or multiple side effects if we want. The function passed to useEffect is a callback function. This will be called after the component renders.

In this function, we can return a function called as CLEANUP Function, This will run as a cleanup process before useEffect Executes the callback function next time and before the component is removed and it does'nt run before the first side effect function execution.
	We can use this cleanup Function to write cleanup logic like timer cleanup,....etc



2Ô∏è‚É£ Argument : Dependencies of this effect - the function only runs if the dependencies changed (array full of dependencies) 


The correct way to perform the side effect in our User component is as follows:

 - We import useEffect from "react"
 - We call it above the returned JSX in our component
 - We pass it two arguments: a function and an array

IMPORTANT! :‚ö†Ô∏è 
If you do not provide the dependencies array at all and only provide a function to useEffect, it will run after every render.

If you forget to provide your dependencies correctly and you are setting a piece of local state when the state is updated, the default behavior of React is to re-render the component. And therefore, since useEffect runs after every single render without the dependencies array, we will have an infinite loop.


useEffect, is a super important hook that helps you deal with code that should be executed in response to something and something could be the component being loaded. It could be the email address being updated. It could be anything, whenever you have an action that should be executed in response to some other action, that is a side effect and that is where a useEffect is able to help you.

‚ùåWhat You Don't Need to Add in useEffect callback Function?

‚ùåYou DON'T need to add state updating functions (as we did in the last lecture with setFormIsValid): React guarantees that those functions never change, hence you don't need to add them as dependencies (you could though)

‚ùåYou also DON'T need to add "built-in" APIs or functions like fetch(), localStorage etc (functions and features built-into the browser and hence available globally): These browser APIs / global functions are not related to the React component render cycle and they also never change

‚ùåYou also DON'T need to add variables or functions you might've defined OUTSIDE of your components (e.g. if you create a new helper function in a separate file): Such functions or variables also are not created inside of a component function and hence changing them won't affect your components (components won't be re-evaluated if such variables or functions change and vice-versa)

‚úÖSo long story short: You must add all "things" you use in your effect function if those "things" could change because your component (or some parent component) re-rendered. That's why variables or state defined in component functions, props or functions defined in component functions have to be added as dependencies!

üß± More About it
 -> https://www.freecodecamp.org/news/react-useeffect-absolute-beginners

 ‚úÖObject properties can be used as dependencies To useEffect.

const { someProperty } = someObject;
useEffect(() => {
  // code that only uses someProperty ...
}, [someProperty]);

This is a very common pattern and approach

We could also write this code and it would work in the same way.

useEffect(() => {
  // code that only uses someProperty ...
}, [someObject.someProperty]);


---------Debouncing----------
Debouncing is a programming practice used to ensure that time-consuming tasks do not fire so often, that it stalls the performance of the web page. In other words, it limits the rate at which a function gets invoked.

Debouncing in JavaScript is a practice used to improve browser performance. There might be some functionality in a web page that requires time-consuming computations. If such a method is invoked frequently, it might greatly affect the performance of the browser, as JavaScript is a single-threaded language. 

Example: 
    var button = document.getElementById("debounce");
    const debounce = (func, delay) => {
        let debounceTimer
        return function() {
            const context = this
            const args = arguments
                clearTimeout(debounceTimer)
                    debounceTimer
                = setTimeout(() => func.apply(context, args), delay)
        }
    }
    button.addEventListener('click', debounce(function() {
            alert("Hello\nNo matter how many times you" +
                "click the debounce button, I get " +
                "executed once every 3 seconds!!")
                            }, 3000));

Explanation: The button is attached to an event listener that calls the debounce function. The debounce function is provided with 2 parameters ‚Äì a function and a Number. Declared a variable debounceTimer, which as the name suggests, is used to actually call the function, received as a parameter after an interval of ‚Äòdelay‚Äô milliseconds. 

If the debounce button is clicked only once, the debounce function gets called after the delay. However, if the debounce button is clicked once, and again clicked prior to the end of the delay, the initial delay is cleared and a fresh delay timer is started. The clearTimeout function is being used to achieve it. 

The general idea for debouncing is: 

 - Start with 0 timeout 
 - If the debounced function is called again, reset the timer to the specified delay 
 - In case of timeout, call the debounced function Thus every call to a debounce function, resets the timer and delays the call. 

Application: Debouncing can be applied in implementing suggestive text, where we wait for the user to stop typing for a few seconds before suggesting the text. thus, on every keystroke, we wait for some seconds before giving out suggestions. Another application of debouncing is in content-loading webpages like Facebook and Twitter where the user keeps on scrolling. In these scenarios, if the scroll event is fired too frequently, there might be a performance impact, as it contains lots of videos and images. Thus the scroll event must make use of debouncing.

ü§êUser Typing : 
Well, the trick is that we actually save the timer and for the next keystroke, we clear it so that we only have one ongoing timer at a time and only the last timer will, therefore, complete and as long as the user keeps on typing, we always clear all other timers and therefore, we only have one timer that completes, and that completes after 500 milliseconds, which is the delay the user has to issue a new keystroke to clear this timer.

-------------useReducer Hookü™ù--------------

Sometimes, you have more complex state - ForExample if it got multiple states, multiple ways of changing it or dependencies to other states.

In such cases useState() then often becomes hard ot error-prone to use - it's easy to write inefficient or buggy code in such scenarios.
 
useReducer can be used as a replacement for useState() if you need "More Powerfull state management"


The useReducer Hook is the better alternative to the useState hook and is generally more preferred over the useState hook when you have complex state-building logic or when the next state value depends upon its previous value or when the components are needed to be optimized.

The useReducer hook takes three arguments including reducer, initial state, and the function to load the initial state lazily.

const [state, dispatchFn] = useReducer(reducerFn, initialArgs, initFn);

1Ô∏è‚É£ -state: The state snapshot used in the component re-render/re-evaluation cycle
2Ô∏è‚É£ -dispatchFn: A function that can be used to dispatch a new action (i.e Trigger an update of the state)

3Ô∏è‚É£ - reducerFn is the user-defined function that pairs the current state with the dispatch method to handle the state. A function that is triggered automatically once an action is dispatched (via dispatchFn)

4Ô∏è‚É£ - initialState refers to the initial arguments
5Ô∏è‚É£ - initFn is the function to initialize the state lazily or programmatically.

‚úÖTo use it, we need to import it first:
   import React, {useReducer} from 'react';

For Example:
	Best Example:
	https://www.freecodecamp.org/news/usereducer-hook-react/

-----------ü§ê useState VS useReducer-----------

üß± -> useState()
	- The main state management "tool"
	- Great for independent pieces of state/data
	- Great if state updates are easy and limited to a few kinds of updates
üß± -> useReducer()
    - Great if you need "More Power"
	- should be considered if you have related pieces of state/data.
	- Can be helpful if you have more complex state updates

------React Context (CONTEXT API)-------
React context allows us to pass down and use (consume) data in whatever component we need in our React app without using props.

In other words, React context allows us to share data (state) across our components more easily.

When should you use React context?
React context is great when you are passing data that can be used in any component in your application.

‚úÖThese types of data include:

 - Theme data (like dark or light mode)
 - User data (the currently authenticated user)
 - Location-specific data (like user language or locale)

 Data should be placed on React context that does not need to be updated often

‚ùìWhat problems does React context solve?
React context helps us avoid the problem of props drilling.

Props drilling is a term to describe when you pass props down multiple levels to a nested component, through components that don't need it.

To establish it:
1Ô∏è‚É£ Create a directory named "Context" or "Store" in the "src" Directory Next to components.

2Ô∏è‚É£ Add a component specific context javascript file in that folder, Example:
 -> For authentication
		-> add auth-context.js
 
3Ô∏è‚É£ In that file include React:
	-> import React from 'react';

4Ô∏è‚É£ write this line:

	//Context -> App or Component wide State
‚è©
		React.createContext(parameter);

	//parameter -> often it is an object

    //It will return a component or an object
    const AuthContext = React.createContext({
		isLoggedIn : false
	});
5Ô∏è‚É£ Export this object
    export default AuthContext;

IMPORTANT! : ‚ö†Ô∏è
The created context is an object with two properties: Provider and Consumer, both of which are components. To pass our value down to every component in our App, we wrap our Provider component around it.

üîÅThere are four steps to using React context:

 - Create context using the createContext method.
 - Take your created context and wrap the context provider around your component tree.
 - Put any value you like on your context provider using the "value" prop.
 - Read that value within any component by using the context consumer.

 ü§ê Read More About:
	https://www.freecodecamp.org/news/react-context-for-beginners/

For listening part (to get access to our value), and we can listen in two ways.

1Ô∏è‚É£ - by using Context consumer
2Ô∏è‚É£ - by using a React Hook. (Mostly Used!)

1Ô∏è‚É£ By first way we need to wrap the component where we want to use the Context Value:

wherever we want to consume (or use) what was provided on our context, we use the consumer component Context.Consumer, To use our passed down value, we use what is called the "render props pattern". It is just a function that the consumer component gives us as a prop and in the return of that function, we can return and use value.

<Context.Consumer>
 ... Here we write a function to which we got argument which has the context data (object which we created in beginning).
	{(ctx) => {
		here .. we return the JSX code which have access to that data.
	}}
</Context.Consumer>

IMPORTANT! : ‚ö†Ô∏è
Technically, we don't need a Provider if we are providing a default value to the context 

We need to pass a prop on Context.Provider named exactly as "value" on which we provide the default values

We can pass anything from functions to values,.... strings etc.

----------useContext Hookü™ù------------

1Ô∏è‚É£ Import it:
	import React , {useContext} from 'react';

2Ô∏è‚É£ Call it in the react component function where you want to use it: PassIt the context which you want to use

	const ctx = useContext(AuthContext);

üëç You can also create your own custom Provider Component as following in the context file:

	const AuthContext = React.createContext({
		isLoggedIn : false,
		onLogout: ()  => {},
		onLogin: () => {}
	});

	//custom Provider Function
	const AuthContextProvider = (props) => {
		//Can be used to bind entire logic

		const [isLoggedIn, setIsLoggedIn] = useState(false);
				
		useEffect(() => {
			const storedUserLoggedInInformation = localStorage.getItem('isLoggedIn');
			if(storedUserLoggedInInformation === '1'){
				setIsLoggedIn(true);
			}
		}, [])

		const logoutHandler = () => {
			localStorage.removeItem('isLoggedIn')
			setIsLoggedIn(false);
		}

		const loginHandler = () => {
			localStorage.setItem('isLoggedIn', '1')
			setIsLoggedIn(true);
		}
		
		return <AuthContext.Provider>props.children</AuthContext.Provider>
	}


Now you can use this AuthContextProvider component and wrap it over your App Component

--------Context Limitation-------
‚ö†Ô∏èReact Context is NOT optimised for high frequency changes!
 -> For example, if you have state changes every second or multiple times per second. 
 -> For that we will utilize something known as Redux

‚ö†Ô∏èReact Context also should'nt be used to replace ALL component communications and props.

 -> Component should still be configurable via props and short 'prop chains' might not need any replacement.

 ----------------Rules of Hooks------------------

1Ô∏è‚É£ Only Call React Hooks in React Functions, and in Custom Hooks.

2Ô∏è‚É£ Only call React Hooks at the TOP LEVEL
	 - Don't call them in Nested Functions
	 - Don't call them in any Block statements
3Ô∏è‚É£ Unofficial Rule for useEffect(): Always add everything you refer to inside of useEffect() as a dependency!
 
----useImperativeHandle Hook-----
useImperativeHandle is a React Hook that lets you customize the handle exposed as a ref.

Functional Components cannot be given refs.
It allows us to use this Component or functionalities from inside this Component imperatively, which simply means not through the regular state props management, not by controlling the Component through state in the parent Component, but instead by directly calling or manipulating something in the Component programmatically.

	useImperativeHandle(ref, createHandle, dependencies?)

	import { forwardRef, useImperativeHandle } from 'react';

	const MyInput = forwardRef(function MyInput(props, ref) {
		//the ref which we are passing is the ref that we want to access from outisde, used for establishing the connection 
		const inputRef
  		useImperativeHandle(ref, () => {
    			return {
      		// ... your methods ...
    			};
  		}, []);
  // ...
üôÖParameters 
1Ô∏è‚É£ref: The ref you received as the second argument from the forwardRef render function.

2Ô∏è‚É£createHandle: A function that takes no arguments and returns the ref handle (an object which contains the data that you want to use from outside of that component) you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.

3Ô∏è‚É£optional dependencies: The list of all reactive values referenced inside of the createHandle code. Reactive values include props, state, and all the variables and functions declared directly inside your component body.

Now, if the parent component gets a ref to MyInput, it will be able to call the focus and scrollIntoView methods on it. However, it will not have full access to the underlying <input> DOM node.

Example: 

//App.js
import { useRef } from 'react';
import MyInput from './MyInput.js';

export default function Form() {
  const ref = useRef(null);

  function handleClick() {
    ref.current.focus();
    // This won't work because the DOM node isn't exposed:
    // ref.current.style.opacity = 0.5;
  }

  return (
    <form>
      <MyInput label="Enter your name:" ref={ref} />
      <button type="button" onClick={handleClick}>
        Edit
      </button>
    </form>
  );
}

//MyInput.js
import { forwardRef, useRef, useImperativeHandle } from 'react';

const MyInput = forwardRef(function MyInput(props, ref) {
  const inputRef = useRef(null);

  useImperativeHandle(ref, () => {
    return {
      focus() {
        inputRef.current.focus();
      },
      scrollIntoView() {
        inputRef.current.scrollIntoView();
      },
    };
  }, []);

  return <input {...props} ref={inputRef} />;
});

export default MyInput;



----------‚è©React.forwardRef--------
The forwardRef method in React allows parent components to move down (or ‚Äúforward‚Äù) refs to their children. ForwardRef gives a child component a reference to a DOM entity created by its parent component in React. This helps the child to read and modify the element from any location where it is used.

‚ùìüò≥How does forwardRef work in React?

In React, parent components typically use props to transfer data down to their children. Consider you make a child component with a new set of props to change its behavior. We need a way to change the behavior of a child component without having to look for the state or re-rendering the component. We can do this by using refs. We can access a DOM node that is represented by an element using refs. As a result, we will make changes to it without affecting its state or having to re-render it.

When a child component needs to refer to its parent‚Äôs current node, the parent component must have a way for the child to receive its ref. The technique is known as ref forwarding.
	
	React.forwardRef((props, ref) => {})

Parameters: It takes a function with props and ref arguments.

Return Value:  This function returns a JSX Element.


------------Section 12: A Look Behind the scenes of React & Optimization Techniquesüé¨-------------

üòµ‚Äçüí´How does REACT Works? 
React -> "A Javascript library for building UI's"

ReactDOM -> Interface to the WEB
React JS does not know the web, it doesnt know anything about the browser, It only knows how to work with components.
It is ReactDOM which ultimately neeeds to bring real HTML elements to the screen.

React Only cares about the components (RealDOM - what user see), props (Data from parent component), state (internal data), context (component wide data).

whenever props, state or context changes, components that use these concepts are updated by React and React checks whether this component now wants to draw something new onto the screen and if that should be the case, React will let ReactDOM know about that so that ReactDOM is able to bring that new screen.

‚ùìHow Exactly Does all that work?
React is concerned about components and what React in the end does is, it uses a concept called the virtual DOM. It determines how the component tree, which your app is building in the end, and every component itself, of course, has a sub tree, that JSX code returned by that component.
It determines how that component tree currently looks like and what it should look like, for example, after a state update and that information is then handed off to ReactDOM which now knows about the differences and which then knows how it should manipulate the real DOM to match that virtual DOM (that virtual snapshot React derived)

whenever state props, or a context of a component changes, that component function is re-executed, that component is re-evaluated by React.

IMPORTANT! : ‚ö†Ô∏è
Re-evaluating a component is not same as re-rendering the DOM. So just because a component function is re-executed by React does not mean that the respective part of the actual real DOM is re-rendered or re-evaluated. Instead we have to differentiate between our component part, our React part and the real DOM.

Now the real DOM on the other hand is only updated in the places where it needs to be changed based on that difference React derived between the previous state of a component and its tree and the current state after the state prop or context change.

So the real DOM is not changed all the time. It's changed rarely and only when needed. And that's important for performance. Because making a virtual comparison between the previous state and the current state, that's fairly cheap and easy to do and that happens only in memory. Reaching out to the real DOM, (that's rendered in the browser)
is pretty expensive from a performance perspective, because working with the real DOM just turns out to be a performance intensive task. 
Ofcourse not a tiny change in one place, but if you do that tiny change in a lot of places all the time, then your page might become slow because you're working with the real DOM too much.
And that's why React has this structure of doing virtual comparisons with that virtual DOM  and then only passing the changes between your last snapshot and the current snapshot to the real DOM.

That's how React works.

ü§êVirtual DOM diffing
Finding out the difference between two snapshots.

Example: 
	ü´£Previous Evaluation Result:

	<div>
	  <h1>Hi there!</h1>
	</div>

all of a sudden we want to show a new paragraph
	ü´£Current Evaluation Result:
	
	<div>
	  <h1>Hi there!</h1>
	  üîÅ<p>This is new!</p>
	</div>

In this case, React would determine that the difference between both snapshots is this p tag and it would report does change to ReactDOM 
so that ReactDOM can update the real DOM and insert this paragraph. ReactDOM would not re-render the entire DOM. It would not touch this existing h1 or div element. It would only insert the paragraph after the h1 element inside of the div.

IMPORTANT! : ‚ö†Ô∏è
-> All  JSX elements in the end are like function calls to the respect of component functions.
If the parent component function runs again of course the child component functions also runs again. So in the end, the prop value doesn't even matter here for this component to be executed again.

-> if a component is re-executed all its child components will also be re-executed and re-evaluated.

ü´£ü§ê‚ùìisn't this bad?
Well, this certainly costs some performance. Of course, we got ongoing function executions. We got a virtual comparison. It's needless to say that React is highly optimized for those executions and comparisons.

But we can as a developer can tell React that it should only re-execute a component under certain circumstances and those circumstances would be that the props, which the component received, changed!

React.memo(); -> it can help here
wrap the component function returned value to it, can be done while exporting it:

This only works for functional components and not for class based components.

Components in React are designed to re-render whenever the state or props value changes. However, this can impact your application's performance because, even if the change is only intended to affect the parent component, every other child component attached to the parent component will re-render. When a parent component re-renders, so do all of its child components.

React Memo is a higher-order component that wraps around a component to memoize the rendered output and avoid unnecessary renderings. This improves performance because it memoizes the result and skips rendering to reuse the last rendered result.

There are two ways you can wrap your component with React.memo(). It is either you wrap the actual component directly without having to create a new variable to store the memoized component:

	const myComponent = React.memo((props) => {
    	/* render using props */
	});

	export default myComponent;

if the parent component changed but the prop values for that component here did not change, component execution will be skipped.

Another option is to create a new variable to store the memoized component and then export the new variable:

	const myComponent = (props) => {
    	/* render using props */
	};

	export const MemoizedComponent = React.memo(myComponent);	

myComponent outputs the same content as MemoizedComponent, but the difference between both is that MemoizedComponent render is memoized. This means that this component will only re-render when the props change.

IMPORTANT! : ‚ö†Ô∏è
A memoized component will only re-render when there is a change in props value or when the state and context of the component change.

ü´£When to use React.memo()‚ùì

You now know what it means to memoize a component and the advantages of optimization. But this doesn‚Äôt mean you should memoize all your components to ensure maximum performance optimization of performance üôÉ.

It is important to know when and where to memoize your component else it would not fulfill its purpose. For example, React Memo is used to avoid unnecessary re-renders when there is no change to the state or context of your component. If the state and content of your component will ALWAYS change, React Memo becomes useless. Here are other points:

 - Use React Memo if your component will render quite often.
 - Use it when your component often renders with the same props. This happens to child components who are forced to re-render with the same props whenever the parent component renders.
 - Use it in pure functional components alone. If you are using a class component, use the React.PureComponent.
 - Use it if your component is big enough (contains a decent amount of UI elements) to have props equality check.

IMPORTANT:
In below Example:
The memoized Profile component will always render even when the user object does not change:

	<!-- Profile.js -->
	import React from 'react';

	const Profile = React.memo(({ userDetails }) => {
		console.log('profile rendered');
		return (
			<div>
				<p>{userDetails.name}</p>
				<p>{userDetails.age}</p>
				<p>{userDetails.userName}</p>
			</div>
		);
	});
	export default Profile;

React Memo doesn't work because it only performs a shallow comparison of the component's properties. Every time the app is updated, the user variable is re-declared, which happens when you use objects. To fix this, use the second argument and provide a custom comparison function.

	<!-- Profile.js -->
	import React from 'react';

	const Profile = React.memo(({ userDetails }) => {
			console.log('profile rendered');
			return (
				<div>
					<p>{userDetails.name}</p>
					<p>{userDetails.age}</p>
					<p>{userDetails.userName}</p>
				</div>
			);
		},(prevProps, nextProps) => {
			if (prevProps.userDetails.name === nextProps.userDetails.name) {
				return true; // props are equal
			}
			return false; // props are not equal -> update the component
		}
	);
	export default Profile;

‚ùåWhen to AVOID using REACT MEMO?

You now understand how to use React Memo, but it is important to note that you should not use it in all situations because it does not always work as expected. Performance-related changes that are implemented incorrectly can even harm performance.

When you need to remember the values of a function or an object, you can use hooks like useMemo() and useCallback(). Also, avoid using React Memo if the component is light and renders with multiple props.

Finally, never use React Memo to wrap a class-based component; instead, extend PureComponent or implement the shouldComponentUpdate() method.

-----------useCallback() Hookü™ù-----------

useCallback is a React Hook that lets you cache/save/store a function definition between re-renders.

	const cachedFn = useCallback(fn, dependencies)

Call useCallback at the top level of your component to cache a function definition between re-renders:

fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On subsequent renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it.

Dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body.The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.

IMPORTANT! : ‚ö†Ô∏è
A component might get removed, and in that case, if it's then later reattached, a new state would be initialized. But as long as a component stays attached to the DOM, state is only updated after that first initialization.
 - same is true for useReducer

State Updates and State Scheduling:

Calling state updating functions in general schedules a state update. React is aware of it, React plans on processing it,
React doesn't process that immediately though. 

Now in reality most of the time, state changes, scheduled state changes will be processed very fast, pretty much instantly. But React reserves the right of actually postponing that state change. React might postpone scheduled state changes.

Now, what React does is, it guarantees you that the order of state changes for one in the same type of state is guaranteed. once that state change was processed, React will re-evaluate the component, it will re-run the component function.

Because of that scheduling where of course you might have multiple outstanding scheduled state changes at the same time, because of that, multiple updates can be scheduled at the same time, because of that, it is recommended that you use this function form for updating your state if you depend on the previous state snapshot. but because it theoretically could be postponed, this is the safe way of ensuring that state changes are processed in order and for every state change where you depend on the previous state,

That's why this function form is helpful because there React will actually ensure that for every outstanding state change, it looks into the latest state and gives you that and does not use the latest state from the last time the component was re-rendered. That's an important difference between when the component was re-rendered and when a state change was scheduled.


---------Batching---------

if you have two state updates in the same synchronous code snippet after each other (in the same function), for example, where nothing in between would cause a time delay or anything like that. In such cases, React will batch those state updates together.

For Example:
In one long synchronous process, so for example, in one function that executes start to end without any callbacks or promises in between, in such cases React will take all the state updates that are produced by that function and it will batch them together into one state update.

----------------useMemo() Hookü™ù-------------------

useMemo is a React Hook that lets you cache the result of a calculation between re-renders.

   const cachedValue = useMemo(calculateValue, dependencies)

Call useMemo at the top level of your component to cache a calculation between re-renders.

1Ô∏è‚É£calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On subsequent renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it in case it can be reused later.

2Ô∏è‚É£dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm.

On the initial render, useMemo returns the result of calling calculateValue with no arguments.

During subsequent renders, it will either return an already stored value from the last render (if the dependencies haven‚Äôt changed), or call calculateValue again, and return the result that calculateValue has returned.

IMPORTANT! : ‚ö†Ô∏è
‚úÖuseMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You can‚Äôt call it inside loops or conditions. If you need that, extract a new component and move the state into it.

‚úÖIn Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.

‚úÖReact will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache‚Äîfor example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate.

-----------------Section 13: An Alternative Way of Building Componenets: Class Based Componentsüî®üß©------------------

1Ô∏è‚É£Functional Component (Default & Most Modern Approach):
	
	function Product(props){
		return <h2>A Product!</h2>
	}

Components are regular JavaScript functions which return renderable results (typically JSX)

2Ô∏è‚É£ClassBased Components  (Alternative for above):
	
	class Product extends Component {

		render(){
			return <h2>A Product!</h2>
		}
	}

Components can also be defined as JS classes where a render() method defines the to-be-rendered output; 

You require these class-based components before React 16.8, because you had to use class-based components to manage 'State'.
            
After, React 16.8 introduced 'React Hooks' for functional components.

---------Creating first class based function----------

	
1Ô∏è‚É£import {Component} from 'react';
This component class, adds important functionality, to make your class work as a component. It also adds a couple of important properties.For example, the props property.

2Ô∏è‚É£		class COMPONENT_NAME extends Component {
		
		//expected by React which react will call when it finds a component being used in JSX code.
		//equivalent to return statement in functional components.
		render(){
			'this.props' is now available after inheriting this class from 'Component' Class
		}

	}

IMPORTANT! : ‚ö†Ô∏è
Class-Based components can work together with functional components, that is you can have both type of components in a project.

--------Working with states and Events (class-based)----------
In class based components you simply adds methods in a class such as (toggleHandler and much more) 

To define 'states' you would use a constructor() method in a class. There you can do initialization of states.

IMPORTANT! : ‚ö†Ô∏è
In a class based component, your state will always be a object and the name of the state is and must be 'state' only. The name is not upto you. Here you have to group all the state that mades the component work into one OBJECT.


	class COMPONENT_NAME extends Component{

		//these methods are those methods which we define in the Component function.
		METHOD_NAME(){
			
		}
		
		//when you add the constructor to the class you must call 'super()' to initialize the parent properties with parent constructor.

		constructor(){
			super();
			this.state = {
				property1: intialValue,
				property2: intialValue,
				property3: intialValue,
				.
				.
				.
			}
		}
	}

To set a state value, we have a predefined function 'setState' which takes an object in the parameter. This won't overwrite the previous state, it will merge it behind the scenes. (Opposite as of functional components).

Here, you can also use the function form but there also you need to return the object.

	this.setState({
		property2: 0
	})
	//merges with the previous state

We can define helper CONST in render functions 

Moreover, you need to bind the 'this' keyword on the methods with the click events and any-other events.
For-Example: 
	the 'onClick' on the button will only work if the this keyword is bind to the instance of the class. 

--------The component life-cycle (class-based)---------
Class-Based components can't use React Hooks!.

Class-based components have access to the lifecycle functions like componentWillMount(), componentDidMount(),componentWillReceiveProps(),componentWillUpdate(), shouldComponentUpdate(),render() and componentWillUnmount();. 

These lifecycle functions are called at different stages of the lifecycle and are used for a variety of purposes like changing the state or doing some work (like fetching data from an external API). They are also referred to as lifecycle hooks. 

componentDidMount() -> called once component mounted (was evaluated & rendered), Equivalent to useEffect( ,[])

componentDidUpdate() -> called once component updated (was evaluated & rendered), Equivalent to useEffect( ,[someValues]);

 - it recieves two arguments (previous props and prev state)

componentWillUnmount() -> called right before component is unmounted (removed from DOM), Equivalent to cleanup function from useEffect, useEffect(()=>{
	return () => {
		//Equivalent
	}
},[] )

-------üéíClass-Based Components and Context--------
Only the data-using part changes as we can' t use React Hooks (particulary useContext), else remains the same, providing the data using provider and all.

We Have two Ways.
1Ô∏è‚É£ Consumer Method:
	-> which is shown in the Context API part.


There is no PERFECT EQUIVALENT METHOD!
2Ô∏è‚É£ A static property named as contextType which is used to access the context data. It can be utilized by using this.context. This method, however, limits your consumption, only one context at a time.

	static contextType = ContextName;

Now you can access it with the help of 'this.context'

---------Introduction to Error Boundries-----------
This could be the reason to use Class-Based Components

Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.

A class component becomes an error boundary if it defines either (or both) of the lifecycle methods static getDerivedStateFromError() or componentDidCatch(). Use static getDerivedStateFromError() to render a fallback UI after an error has been thrown. Use componentDidCatch() to log error information.


	class ErrorBoundary extends React.Component {
	constructor(props) {
		super(props);
		this.state = { hasError: false };
	}

	static getDerivedStateFromError(error) {
		// Update state so the next render will show the fallback UI.
		return { hasError: true };
	}

	componentDidCatch(error, errorInfo) {
		// You can also log the error to an error reporting service
		logErrorToMyService(error, errorInfo);
	}

	render() {
		if (this.state.hasError) {
		// You can render any custom fallback UI
		return <h1>Something went wrong.</h1>;
		}

		return this.props.children; 
	}
	}

Then you can use it as a regular component:

	<ErrorBoundary>
	<MyWidget />
	</ErrorBoundary>


Error boundaries work like a JavaScript catch {} block, but for components. Only class components can be error boundaries. In practice, most of the time you‚Äôll want to declare an error boundary component once and use it throughout your application.


‚ùìWhere to Place Error Boundaries
The granularity of error boundaries is up to you. You may wrap top-level route components to display a ‚ÄúSomething went wrong‚Äù message to the user, just like how server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.

‚ùìHow About try/catch?
try / catch is great but it only works for imperative code. React components are declarative and specify what should be rendered.

Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a componentDidUpdate method caused by a setState somewhere deep in the tree, it will still correctly propagate to the closest error boundary.

‚ùìHow About Event Handlers?
Error boundaries do not catch errors inside event handlers. React doesn‚Äôt need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle methods, the event handlers don‚Äôt happen during rendering. So if they throw, React still knows what to display on the screen. If you need to catch an error inside an event handler, use the regular JavaScript try / catch statement.


IMPORTANT! : ‚ö†Ô∏è
Error boundaries only catch errors in the components below them in the tree. An error boundary can‚Äôt catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how the catch {} block works in JavaScript.
As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.



-----------------Section 14: Sending Http Requests (e.g. connecting to the database)üìñ------------------
AXIOS (a package for javascript) could be used to send http requests 
Fetch API : BUILT into Browsers, allows to send and fetch some data to/from the API

‚úÖIf we are fetching a resource from an API and we got an unsuccessful status code. By default, the Fetch API doesn't throw back an error. Axios, on the other hand, would generate and throw a real error for error status codes.

‚úÖYou can use States for various states like Loading, error, loadedResource etc.....

‚úÖuseEffect can be used to do side works like fetching data immediately after the component loads side by side preventing infinite loop; 

----------------Section 15: Building Custom React Hooks-------------------

Custom React JS hooks are reusable functions that a React JS software developer can use to add special and unique functionality to the React applications. Usually, if there is a requirement to add a feature, one can install a third-party library and solve the problem. But what if there is no such library with hooks that can be used? This problem is solved by using custom React JS hooks.

A custom hook is a special JavaScript function whose name starts with ‚Äòuse‚Äô and can be used to call other hooks. Let‚Äôs take a look at some major differences between a custom React JS hook and React JS components:

 - A custom hook does not require a specific signature.
 - A software developer can choose what argument the custom hook has and what should the argument return.
 - A custom hook always starts with the name ‚Äòuse‚Äô.

 ‚úÖ Outsource stateful logic into re-usable functions.
 unlike "regular functions", custom hooks can use other react hooks and react state.
 
 ‚≠ê How can we create a custom Hook?
1Ô∏è‚É£ like components, we create a seperate directory for our custom "Hooks"

2Ô∏è‚É£ Create a file, by naming like use-< useForTheHook >.js
Example:
	ü´£use-counter.js

‚úÖIf you call a custom hook in one of your components and that component, for example of registers a state or an effect, then this state and effect will be tied to the component in which you use your custom hook.

‚úÖIf we use a custom hook in multiple components, every component will receive its own state.

You can return whatever you wanna return in your custom hooks. Could be an array or an object or a number or a state variable.

---------------------------------------Section 18: Diving deep into REDUXü§ø-----------------------------------------

‚≠êRedux is a third party react library.

‚úÖRedux is a state management system for a cross-component or app-wide state. So it helps us manage state (data that changes and affects our application) and what we display on the screen.

‚úÖIt helps us manage such data across multiple components or even the complete app.

‚ùìWhat is Cross-Component/App-Wide state

So, There are three main kinds of state.
1Ô∏è‚É£ Local state
 -> It is a state which belongs to a single component 
 -> For example, if we listen to a user input and we use useState to store that input with every keystroke in a state variable.
               Or 
We have a button that toggles some detailed field. So if we click that button we show the details, if we click it again we hide them.
It should be managed component-internal with useState() / useReducer().


2Ô∏è‚É£ Cross-Component
-> It is a state that affects multiple components
-> For example, if we have a button that opens or closes a modal overlay such a modal component might affect multiple components and the trigger for opening the modal is per definition not inside of the modal. On the otherhand, the modal might be closed by clicking a button which is inside of that modal.

So, then we have multiple components working together to display and hide a modal.

-> Require "prop chains" / "prop drilling"
3Ô∏è‚É£ App-Wide State
-> Is is a state that does not just affect multiple components but basically all components of an application.
-> For example: user authentication, If we log in we might need to change the navigation bar because we now show new options and we also certainly affect a lot of other components which now show more or less data. 
-> Requires "props chains" / "props drilling"

For cross-component and app-wide state passing around data and updating function through props can become cumbersome though.

Redux solves the same problem. So both REACT CONTEXT and REDUX are there to help us manage such cross-component or app-wide States.

You can also use both Contexts and Redux in the same application.

REACT CONTEXT vs REDUXüòµ‚Äçüí´
-> REACT CONTEXT has a couple of potential disadvantages.
   -> With React Context, you can have a very complex setup and managing state with React Context can become quite complex. You can end up with deeply nested JSX code.

-> Performance can be an issue, it works good for low frequency states updates like theme changing, authentication but for high frequency state updates its not well suited - as quoted by an Official React TEAM Member.

‚ùìHow REDUX Works?

Redux is all about having one Central Data (state) Store, in your application.
You have exactly one store. You never have more than one store.
It's one store, for all your state for your entire application.

In that state you could store authentication, themeing .... etc.

For this components set up subscriptions, to our Central Store. They subscribe to the store, and whenever the data changes, the store notifies components, and then components can get the data they need, for example the current authentication status, so they get a slice of the Redux store, and they can then use it.

      |--------------------Reducer function
	|   (forwarded to)        |
	|				  | Mutates (= changes) Store Data
	|				  |
	|				  V
   Action		    CENTRAL DATA (STATE)
    	|				  |
	|				  | (Subscriptions)
	|				  |
	|	   (Dispatch)	  V
	|---------------------Components

‚ö†Ô∏èComponents Never, directly manipulate the store data. So we have that subscription, but we don't have a data flow in the other direction. (At least not a direct data flow.)

Instead for that, we use a concept called REDUCERS. We have a reducer function. This reducer function which we have to set up. This function is responsible, for mutating. So for changing the store data.

	             useReducer !== reducer (here)

üòµ‚Äçüí´How do we now connect components and that reducer function?

it will ofcourse be the components that should trigger a data change. It is for example a click on a button in a component that should trigger some data change. So how do we connect that?
(Trigger)We have actions and components dispatch actions.


Now an action is really just a simple JavaScript object, which describes the kind of operation, the reducers should perform. Therefore, Redux then forwards actions to the reducer, reads that description of the desired operation, and then this operation is performed by the reducer.

So components dispatch actions, which describe what should be done, but don't do it directly, then these actions are forwarded to the reducer, the reducer then does what the action wants, the reducer to do and then the reducer, spits out a new state, which effectively will replace the existing state in that Central Data Store and when that happens, subscribing components are notified, so that they can update their UI.

That's how Redux works!ü´£

üõ£Ô∏èPrinciples of Redux
Predictability of Redux is determined by three most important principles as given below ‚àí

1Ô∏è‚É£Single Source of Truth
The state of your whole application is stored in an object tree within a single store. As whole application state is stored in a single tree, it makes debugging easy, and development faster.

2Ô∏è‚É£State is Read-only
The only way to change the state is to emit an action, an object describing what happened. This means nobody can directly change the state of your application.

3Ô∏è‚É£Changes are made with pure functions
To specify how the state tree is transformed by actions, you write pure reducers. A reducer is a central place where state modification takes place. Reducer is a function which takes state and action as arguments, and returns a newly updated state.

ü™úTo install redux, you can follow the below steps ‚àí

‚úÖRun the following command in your command prompt to install Redux.

	> npm install --save redux

‚úÖTo use Redux with react application, you need to install an additional dependency as follows ‚àí

	> npm install --save react-redux

‚úÖTo install developer tools for Redux, you need to install the following as dependency ‚àí

Run the below command in your command prompt to install Redux dev-tools.

	> npm install --save-dev redux-devtools

üë•How to use Redux?
A reducer function is a standard JavaScript function, but it will it be called by the Redux library and it will then always receive two pieces of input, two parameters, 
 
1Ô∏è‚É£ - the old or existing state and 
2Ô∏è‚É£ - the action that was dispatched.

then this reducer function must return a certain output. It must always return a new state object. And therefore a reducer function should be a pure function. Which basically means that the same inputs, the same values for inputs always should produce exactly the same output.

ü´£Example - How to use it?
Let us assume our application‚Äôs state is described by a plain object called initialState which is as follows ‚àí

	const initialState = {
   		isLoading: false,
   		items: [],
   		hasError: false
	};

Every piece of code in your application cannot change this state. To change the state, you need to dispatch an action.

üé¨What is an action?
An action is a plain object that describes the intention to cause change with a type property. It must have a type property which tells what type of action is being performed. The command for action is as follows ‚àí

	return {
   		type: 'ITEMS_REQUEST', //action type
   		isLoading: true //payload information
	}
Actions and states are held together by a function called Reducer. An action is dispatched with an intention to cause change. This change is performed by the reducer. Reducer is the only way to change states in Redux, making it more predictable, centralised and debuggable. A reducer function that handles the ‚ÄòITEMS_REQUEST‚Äô action is as follows ‚àí

	const reducer = (state = initialState, action) => {
   		switch (action.type) {
      		case 'ITEMS_REQUEST':
         			return Object.assign({}, state, {
            		isLoading: action.isLoading
         			})
      		default:
         			return state;
   		}
	};

Redux has a single store which holds the application state. If you want to split your code on the basis of data handling logic, you should start splitting your reducers instead of stores in Redux.

Redux follows the unidirectional data flow. It means that your application data will follow in one-way binding data flow. As the application grows & becomes complex, it is hard to reproduce issues and add new features if you have no control over the state of your application.

Redux reduces the complexity of the code, by enforcing the restriction on how and when state update can happen. This way, managing updated states is easy. We already know about the restrictions as the three principles of Redux. Following diagram will help you understand Redux data flow better (In The Github).

‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Attach the link

An action is dispatched when a user interacts with the application.

The root reducer function is called with the current state and the dispatched action. The root reducer may divide the task among smaller reducer functions, which ultimately returns a new state.

The store notifies the view by executing their callback functions. The view can retrieve updated state and re-render again.

üè™What is a Store?

A store is an immutable object tree in Redux. A store is a state container which holds the application‚Äôs state. Redux can have only a single store in your application. Whenever a store is created in Redux, you need to specify the reducer.

Let us see how we can create a store using the createStore method from Redux. One need to import the createStore package from the Redux library that supports the store creation process as shown below ‚àí

	import { createStore } from 'redux';
	import reducer from './reducers/reducer'
	const store = createStore(reducer);

A createStore function can have three arguments. The following is the syntax ‚àí

	createStore(reducer, [preloadedState], [enhancer])

A reducer is a function that returns the next state of app. A preloadedState is an optional argument and is the initial state of your app. An enhancer is also an optional argument. It will help you enhance store with third-party capabilities.

A store has three important methods as given below.

1Ô∏è‚É£getState()
It helps you retrieve the current state of your Redux store. The syntax for getState is as follows ‚àí

	store.getState()

2Ô∏è‚É£dispatch()
It allows you to dispatch an action to change a state in your application. The syntax for dispatch is as follows ‚àí

	store.dispatch({type:'ITEMS_REQUEST'})
3Ô∏è‚É£subscribe()
It helps you register a callback that Redux store will call when an action has been dispatched. As soon as the Redux state has been updated, the view will re-render automatically. The syntax for dispatch is as follows ‚àí

store.subscribe(()=>{ console.log(store.getState());})
Note that subscribe function returns a function for unsubscribing the listener. To unsubscribe the listener, we can use the below code ‚àí

	const unsubscribe = store.subscribe(()=>	{console.log(store.getState());});
	unsubscribe();

üçíWhat is a Reducer?
Reducers are a pure function in Redux. Pure functions are predictable. Reducers are the only way to change states in Redux. It is the only place where you can write logic and calculations. Reducer function will accept the previous state of app and action being dispatched, calculate the next state and returns the new object.

The following few things should never be performed inside the reducer ‚àí

‚ùåMutation of functions arguments
‚ùåAPI calls & routing logic
‚ùåCalling non-pure function e.g. Math.random()

The following is the syntax of a reducer ‚àí

	(state,action) => newState

we can write our logic in reducer and can split it on the logical data basis. Let us see how we can split reducers and combine them together as root reducer when dealing with a large application.

Suppose, we want to design a web page where a user can access product order status and see wishlist information. We can separate the logic in different reducers files, and make them work independently. Let us assume that GET_ORDER_STATUS action is dispatched to get the status of order corresponding to some order id and user id.


IMPORTANT! : ‚ö†Ô∏è
There should be no side effects inside of that function. So you must not send a HTTP request or write something to local storage or fetch something from local storage there.

/reducer/orderStatusReducer.js
import { GET_ORDER_STATUS } from ‚Äò../constants/appConstant‚Äô;
export default function (state = {} , action) {
   switch(action.type) {
      case GET_ORDER_STATUS:
         return { ...state, orderStatusData: action.payload.orderStatus };
      default:
         return state;
   }
}


/reducer/getWishlistDataReducer.js
import { GET_WISHLIST_ITEMS } from ‚Äò../constants/appConstant‚Äô;
export default function (state = {}, action) {
   switch(action.type) {
      case GET_WISHLIST_ITEMS:
         return { ...state, wishlistData: action.payload.wishlistData };
      default:
         return state;
   }
}

we can combine both reducers by using Redux combineReducers utility. The combineReducers generate a function which returns an object whose values are different reducer functions. You can import all the reducers in index reducer file and combine them together as an object with their respective names.

/reducer/index.js
import { combineReducers } from ‚Äòredux‚Äô;
import OrderStatusReducer from ‚Äò./orderStatusReducer‚Äô;
import GetWishlistDataReducer from ‚Äò./getWishlistDataReducer‚Äô;

const rootReducer = combineReducers ({
   orderStatusReducer: OrderStatusReducer,
   getWishlistDataReducer: GetWishlistDataReducer
});
export default rootReducer;

Now, you can pass this rootReducer to the createStore method as follows ‚àí

const store = createStore(rootReducer);

STEPS TO FOLLOW WHILE WORKING WITH REACT and REDUX ALTOGETHER!

1Ô∏è‚É£ Install npm package : react-redux
	> npm i react-redux
	> npm i redux
2Ô∏è‚É£Create the store directory in the react app and create an index.js file inside it, and write the following accordingly:
	//creating the store
	import {createStore} from 'redux';

	//creating the reducer function
	const counterReducer = (state = {counter: 0},action) => {
	if(action.type === 'INCR'){
		return {
			counter: state.counter + 1
		}
	}
	if(action.type === 'DECR'){
		return {
			counter: state.counter - 1
		}
	}
	return state;
	};

	//creating the store
	const store = createStore(counterReducer);

	//export the store
	export default store;

IMPORTANT! : ‚ö†Ô∏è
The object which we are returning in our reducer, in our Redux reducer, return a brand new snapshot, a brand new state object which Redux will use to replace its existing state with, So the objects which we return will not be merged with the existing state. They will overwrite the existing state.

So we must always set all the other states when we update a piece of state because we overwrite the old state.

‚ùåYou should never super important never mutate the state, the existing state.

‚ùå	if(action.type === 'INCR'){
			state.counter++;
			return state;
		}
‚úÖInstead, always override it by returning a brand new state object.


This can lead to bugs, unpredictable behavior and it can make debugging your application harder as well.
So even though it doesn't lead to a bug here it can have unwanted and unexpected side effects in bigger applications where your state gets out of sync and suddenly the UI is not reflecting your state correctly anymore.

‚úÖDo this in an immutable way

3Ô∏è‚É£ Provide the store to the app or the highest level >
by going to the react "index.js" file in the "SRC" folder

	import React from 'react';
	import ReactDOM from 'react-dom/client';
    ‚≠ê  import { Provider } from 'react-redux';

	import './index.css';
	import App from './App';

	const root = ReactDOM.createRoot(document.getElementById('root'));
	root.render(
	‚≠ê	<Provider>
			<App />
	‚≠ê	</Provider>
	);

You could also wrap nested components (not only the highest one) with provider, but only wrapped components and their child components, and their child components of the child components, and so on. Only those components will have access to Redux thereafter.

Now just by wrapping Provider around app, we're not telling react Redux and react therefore  which store we wanna provide.

So, we have to import store from our index.js file in Store directory.

	import store from './store/index'

and then therfore tell provider that you are providing this store by:
pointing that imported store on the special prop that is available on Provider.

	<Provider store={store}>

Now the app and its child components i.e the whole app can use the store.
ü´£They can get data out of the store.

ü´£They can set up a subscription to that data to be precise.

ü´£They also can dispatch actions.

-----useSelector, useDispatch Hookü™ù-----

----useSelector Hookü™ù----

- useSelector is a function that takes the current state as an argument and returns whatever data you want from it. It‚Äôs very similiar to mapStateToProps() and it allows you to store the return values inside a variable within the scope of you functional components instead of passing down as props.

- used to select/get part of the state managed by redux.

- When you use useSelector(), react-redux will automatically set a subscription to the redux store for this component in which you are using useSelector() and will recieve the latest value automatically whenever that changes in the redux store (that you are getting as a part of the state)

- Its automatically reactive Changes to the Redux store will cause the component function to be re executed.

- If you ever would unmount/remove the component which is utilizing the store, React Redux would also automatically clear the subscription for you. So,  it manages that subscription for you behind the scenes.


-----useDispatch Hookü™ù------

 - useDispatch is a function that we import from react-redux library and assign it to a variable. And with this, we are able to dispatch any action to the store by simply adding an action as an argument to the new variable like the code above and that‚Äôs it.

 - returns a dispatch function a function which we can call, which will dispatch an action against our Redux store.

----Attaching payloads to actions----
We can't predict all possible values we might wanna support in the actions (in the reducer function),

you can't hard-code those values here in your Reducer.

Instead, the action which we dispatch and which reaches the Reducer often needs to carry extra data.

‚≠êwhatever you want to configure
	const payload = {...}

	dispatch({type: 'action-name', payload});

- It adds dynamism to the reducer function

------Redux: TOOLKIT------
‚åöworking with redux alot easier.

TO start working:
	> npm i @reduxjs/toolkit

After installing you can then uninstall redux library because that is already included in this package.

For docs refer: 
	https://redux-toolkit.js.org/


--------------Section 19: Advanced ReduxüíØ--------------
 
---------Side Effects, Async Tasks & Redux---------
‚ö†Ô∏èReducers must be pure, side-effect free, synchronous functions.

Working should be :
		Input (Old State + Action) ---> Output (New State)

Where should we put our side effect code and async tasks to be executed?
There can be two possible places:
1Ô∏è‚É£ Directly inside the components function (EG. useEffect());
 - we only dispatch an action once that side effect is done So, Redux doesn't know anything about that side effect.

2Ô∏è‚É£ Inside the action Creators Functions (üÜï)
‚úÖRedux actually has a solution that allows us to perform side effects and run asynchronous tasks as part of this action creators without changing the reducer function because that function must stay side effect free.

-------Frontend VS Backend Code------------
Frontend Code Depends on Backend Code

		    --------Backend API
			|			^
			|			|
			V			|
	Does a lot of work  |
	(transform data)    |
			^			|
			|			|
			V			|
	Send data & recieve	|
	+ use response		|
	(less code on Frend)|
			|			V
			|-------Frontend React App

ü§îWhere to put our logics (code)?
Fat Reducers vs Fat Components vs Fat Actions

‚åöIf the code to be written is synchronous, side-effect free code (i.e Data Transformation)
‚úÖ -> Prefer Reducers
‚ùå ->  Avoid Action Creators or Components

‚åöIf the code to be written is Asynchronous with side-effects (i.e Data Transformation)
‚úÖ -> Prefer Action Creators or Components
‚ùå -> Never use Reducers

useEffect has a problem of whenever the component loads for the first time it will always run for that time, So due to that you need to explicitly handle it.

--------Action Creator----------
		---Thunk---
‚åöA thunk is simply a function, that delays an action until later, until something else finished.


	-----common pattern------
An action creator, which does not immediately return the action object, but which instead, returns another function which eventually returns the action. So that we can run some other code before we then dispatch the actual action object that we did want to create.

# In Redux Toolkit (Automatically created by Redux Toolkit)
Every method in the reducers object, receives such an action creator, which is called, by using that reducer function name.


const ActionCreator = (data) => {
	return async (dispatch) => {
		dispatch()
	};	
}

we can perform any asynchronous code, any side effects,  because we will not yet, have reached our reducer. We're not running this code in a reducer. It's a separate standalone JavaScript function instead.


-------TOBE CONTINUEDüéóÔ∏è---------



üîÅ Rewatch 260: using an action creator Thunk



----------Redux DevTools------------
Developer Tools to power-up Redux development workflow or any other architecture which handles the state change.
It can be installed as a standalone app or a chrome Extension.
-It let us know various dipatches across the App and much more 
- Redux toolkit gives us it automatically.

https://github.com/reduxjs/redux-devtools

------Section 20: Building a MULTI PAGE SPA with React Router-------
------What is Routing?--------
üåêURL changes 
		/welcome -> /products
		   |           |
		   |		   |
     (welcome.html)	(products.html)     
(Traditionally, loading diffrent html pages)
‚ö†Ô∏èvisible content changes

‚åöWhen building complex user interfaces, we typically build Single Page applications (SPAs)
‚úÖOnly one initial HTML request and response
(We can )

Send only one initial HTML request and then this HTML file with a bunch of extra JavaScript is downloaded, and thereafter the extra JavaScript code that runs on the client will actually take care about adjusting what the user sees on the screen. That's how single page applications work.


We can add client-side React code that basically watches the currently active URL and that triggers whenever the URL changes, and that then leads to different content being displayed on the screen when the URL changes. So instead of loading new HTML files from the backend, we could add some client-side code that simply watches the URL and then loads a different React component when that URL changes. 
			
(changes the visible content without fetching a new HTML file)

To work with Multipage SPA's, we need a extra package called as 'react-router-dom' (belongs to the react router tool)

     üåêhttps://reactrouter.com/en/main

üéóÔ∏èInstall the following package:

	> npm i react-router-dom

It's this package which allows us to listen to URL changes and then load different content.

To start adding Routing to the application.It has various steps:

1Ô∏è‚É£Define the routes we wanna support:
 - Define which URLs, paths to support and which components should be loaded for different paths.

2Ô∏è‚É£Activate the Router and load the route definations that we defined in first step.

3Ô∏è‚É£To make sure that we have all these components that we do wanna load and that we maybe also provide some means of navigating between those pages so that our users can move smoothly between the different pages.
(Routes are simply path or component mappings. So for which path (like "/products") should which component (like <Products />) be loaded)

‚úÖ Working with the 1Ô∏è‚É£ step:

Import the "createBrowserRouter" Function from "react-router-dom" package in APP component (root component)

 import {createBrowserRouter} from 'react-router-dom'

We call this function and to this function, we pass an array of route definition objects. So here we provide a couple of JavaScript objects  where every object represents one route. And we add some properties to define the route characteristics like for example, the path for which this route should be activated. The path is the part after the domain.


‚úÖ We add components that will be loaded as pages in a separate folder under "src" named "pages" / "routes".

‚úÖ Create separate compoents which need to be loaded when we hit that Route.

 - Your createBrowserRouter function will look like this:

	createBrowserRouter([
	{
		path: '/',
		element:<HomePage/>
	},
	{},
	])

Now to use this, we must accept the return value provided by this above function

	const router = createBrowserRouter([
	{
		path: '/',
		element:<HomePage/>
	},
	{},
	])

We need this constant to then tell React that this router should be rendered to the screen, so to say, or that that router should be loaded and should render the appropriate pages to the screen.

So therefore, we need to import another thing from react-router-dom

import {RouterProvider} from 'react-router-dom'


This router provider component has a special prop which we must set, (the router prop) and the value we pass to the router prop should be a router created with create browser router.

In the App.js and App function

    return <RouterProvider router = {router}/>


So now, we're rendering the router on the screen and we're activating the router and the router will then therefore, take a look at the url, see what the currently active path is, and load the appropriate element if that currently active path is supported.

IMPORTANT! : ‚ö†Ô∏è
If we enter something totally different, we get an error, though because we try to visit a URL, a path that's not supported yet.

------Alternative way of defining routes------
 - createRoutesFromElements
	- Explore it Seperately

------üó∫Ô∏ènavigating between pages using links-------

PROBLEM! : ‚ùå
Adding a link with the default anchor element and this default HTML anchor element takes a href attribute, which could lead to (like /products) a url to be specific and if we click it, we go to The Products Page. We have a problem with this approach. If you watch this refresh icon on the browser, you will see that it briefly flashes and turns to a cross and back to a refresh icon.

The reason for that is that technically, we sended a new request to the server that's serving this website. Now, that server will serve back that single HTML page that makes up this single page application but what happens under the hood is that we, of course, load all the JavaScript code again, load the entire React application again and restart the React application. 
That's a lot of unnecessary work under the hood that can also impact the site performance, which we typically wanna avoid because we already loaded all the JavaScript code. We don't wanna load it again and we don't wanna restart the React application. We would also lose any context or application-wide state if we do so. So we don't wanna switch the page by sending a new HTTP request to the server with that, we lose all the benefits of single page applications.

‚úÖTo solve it we need to import another component from 'raect-router-dom' (where you want to add a link) named as "Link"

	<p>
		Go to 
		<Link to="/products">
			list of products
		</Link>
	</p>

So, the Link component renders an anchor element and listens for clicks on that element, prevents the browser default of sending a HTTP request if the link is clicked and instead simply takes a look at the route definitions to update the page accordingly and load the appropriate content. It will also change the URL but without sending a new HTTP request.

The above way is how we should navigate between pages.


-----Layouts and Nested Routes-----

To add a global layout such as a nav-bar, main-layout, we need some features.

We can do this Seperately in all components as it is a global layout, it needs to be there in every compoent, BUT, it will leads to repetition of code (violating DRY!)

What we will or can do, we can wrap a layout route that can wrap all other routes as children

IMPORTANT! : ‚ö†Ô∏è
Link (Component provided by react-router-dom) only work if rendered inside of the router provider.

So to solve the problem of global layout, you add a extra route (path should be '/' as for global)


Nested Routes EXample:
	const router = createBrowserRouter([
	{
		path: '/',
		element:<RootLayout/>,
		children: [
		{
			path: '/',
			element: <HomePage />
		},
		{
			path: '/products',
			element: <ProductsPage />
		},
		]
	},
	]);

Here the RootLayout is the layout layout of the root page so to say, or can be the base page or component to be rendered.
We have wrapped the other 2 routes ('/', and '/ProductsPage') inside the root route. So,
This route ('/' at the top) acts as a parent route to these routes and it acts as a wrapper to these routes.

We wrap the routes with a special property called as 'children' which takes an array of route objects.

So inside the root route component (i.e.'RootLayout'), we need to tell react that where should the children components render.
For this, we use 'Outlet', This component marks the place where the child route elements should be rendered to.



	//inside Root.js in 'pages' directory
	import {Outlet} from 'react-router-dom'

	function RootLayout(){
		return (
			<>
				<h1>
					Root Layout
				</h1>
				<Outlet/>
			</>
		);
	}

	export default RootLayout;


‚úÖ <Outlet/>
this is now the marker, the place, where the child routes (ie. HomePage ('/'), ProductsPage ('/products')) should be rendered to.

üòÉThe advantage of this approach, You can have path dependent layout wrappers.

The root route is admittedly weird. We call it a layout route because it doesn't participate in the matching at all (though its children do). It only exists to make wrapping multiple child routes in the same layout simpler. If we didn't allow this then you'd have to handle layouts in two different ways: sometimes your routes do it for you, sometimes you do it manually with lots of layout component repetition throughout your app

IMPORTANT! : ‚ö†Ô∏è
Don't forget to add an <Outlet> to your layout where you would like child route elements to be rendered. Using {children} will not work as expected.

----Showing Error pages with errorElement----
Exapmle page: 
	import MainNavigation from '../components/MainNavigation';
	function ErrorPage(){
		return (
			<>
				<MainNavigation/>
				<main>
					<h1>An error occured!</h1>
					<p>Could not find this page!</p>
				</main>
			</>
		);
	}
	export default ErrorPage;

When exceptions are thrown in loaders, actions, or component rendering, instead of the normal render path for your Routes (<Route element>), the error path will be rendered (<Route errorElement>) and the error made available with useRouteError.

IMPORTANT! :‚ö†Ô∏è
This feature only works if using a data router like 'createBrowserRouter'.

BUBBLINGü´ß
When a route does not have an errorElement, errors will bubble up through parent routes. This lets you get as granular or general as you like.

Put an errorElement at the top of your route tree and handle nearly every error in your app in one place. Or, put them on all of your routes and allow the parts of the app that don't have errors to continue to render normally. This gives the user more options to recover from errors instead of a hard refresh and ü§û.

If you do not provide an errorElement in your route tree to handle a given error, errors will bubble up and be handled by a default errorElement which will print the error message and stack trace. Some folks have questioned why the stack trace shows up in production builds. Normally, you don't want to expose stack traces on your production sites for security reasons. However, this is more applicable to server-side errors (and Remix does indeed strip stack traces from server-side loader/action responses). In the case of client-side react-router-dom applications the code is already available in the browser anyway so any hiding is just security through obscurity. Furthermore, we would still want to expose the error in the console, so removing it from the UI display is still not hiding any information about the stack trace. Not showing it in the UI and not logging it to to the console would mean that application developers have no information at all about production bugs, which poses its own set of issues. So, again we recommend you always add a root level errorElement before deploying your site to production!

Link vs NavLink vs anchor tag
When utilizing react-router-dom, there are three main ways to create links: NavLink, Link, and an anchor tag (<a>)
--Link--
The Link component is provided by react-router-dom and is used to navigate within the app. It renders an anchor tag (<a>) under the hood, which links to internal routes. The Link component utilizes the ‚Äúto‚Äù attribute, which can be either a string or an object. If the ‚Äúto‚Äù attribute is a string, it will render an anchor tag with an href equal to the string.

If the ‚Äúto‚Äù attribute is an object, it will render an anchor tag with an href equal to the pathname of the object. If the object version of the ‚Äúto‚Äù attribute is used, you can pass four different properties: pathname (the path link), search (query params), hash (to put in URL), and state (persisting state).

--NavLink--

NavLink is similar to Link, but it has the ability to add additional styling attributes to the element. For example, you can use NavLink to style the active link differently than the other links. NavLink utilizes the ‚ÄúactiveClassName‚Äù attribute. This is the class that will be applied to the element when it is active.

here the className attribute works a bit different, it's a prop that takes a function and that function should return the class name, the CSS class name that should be added to the anchor tag. That function also automatically receives an object from which we can de-structure the "isActive" property and this object with the isActive property is provided by a react-router-dom and is active as a Boolean, that's true if this link is currently active.
or it's false if it is not currently active route.

	<NavLink to='/' className={({isActive}) => {return isActive ? classes.active : undefined  }}>
		Home
	</NavLink>

You get the same function for inline styles.

IMPORTANT! : ‚ö†Ô∏è
By default NavLink actually checks whether the path of the currently active route starts with the path of one of other NavLinks and that NavLink is considered to be active. if the currently active route starts with the path set on the link and that behavior exists so that a link could be treated as active even if you're on some nested child route.

To solve this issue we have another prop named 'end' which we can set to true or false.This indicates that this link should only be considered active if the currently active route ends with the provided path after the URL.

	<NavLink to='/' className={({isActive}) => {return isActive ? classes.active : undefined  }} end>
		Home
	</NavLink>


--Anchor Tag (<a>)--
An anchor tag is an HTML element that is used to create a link to another page. The anchor tag has an href attribute, which specifies the URL of the page that the link goes to. The anchor tag is different than Link and NavLink because it does not utilize React Router. It is used for linking to external pages or for creating links that do not go to a specific route in the React application.

-----Imperative Routing------
Providing navigation to users in some situations, for example, when form was submitted, or because some timer expired, trigger a navigation action from inside Code by using another special feature provided by react-router-dom.
 --useNavingate Hookü™ù--
The useNavigate hook returns a function that lets you navigate programmatically, for example:

	import { Link, useNavigate } from "react-router-dom";


	function HomePage() {
		const navigate = useNavigate();

		function navigateHandler(){
			navigate('/products');
		}

		return (
			<>
				<h1>My Home Page</h1>
				<p>Go to <Link to="/products">list of products</Link></p>
				<p>
					<button onClick = {navigateHandler}>navigate</button>
				</p>
			</>
		)
	}

	export default HomePage;

Here when the user clicks the button, navigateHandler will execute and further leads to calling of navigate('/products') which will lead to programmatically navigation to http://localhost:port/products 


üó∫Ô∏èThe navigate function has two signatures:

1Ô∏è‚É£Either pass a To value (same type as <Link to>) with an optional second { replace, state } arg.
2Ô∏è‚É£Pass the delta you want to go in the history stack. For example, navigate(-1) is equivalent to hitting the back button.

IMPORTANT! : ‚ö†Ô∏è 
It's usually better to use redirect in loaders and actions than this hook

----Dynamic Routing----
üéóÔ∏èDynamic Path segments and Path Parameters or Params
Example to route /products/product-1 , /products/product-2 .... etc based on some variable.

Route params are parameters whose values are set dynamically in a page‚Äôs URL. This allows a route to render the same component while passing that component the dynamic portion of the URL, so that it can change its data based on the parameter.

Examples of URL route params you might recognize include things like IDs for products, books, users, or, in my case, movies. At least with React, in order to get the details for the correct item, the dynamic component would need the unique, specific ID of the item supplied, so it could get the correct data to display.

Examples:
	<Route exact path="/movie/:id" component={MovieDetailsContainer} />

	{
       path: '/products/:productId',
       element: <ProductDetailPage />
    }

--useParams Hookü™ù--
The useParams hook returns an object of key/value pairs of the dynamic params from the current URL that were matched by the <Route path>. Child routes inherit all params from their parent routes.

The useParams() hook is a React Router hook that allows you to access the parameters of the current URL. This can be useful if you want to dynamically render content based on the URL parameters. For example, if you have a blog application, you may want to render different articles based on the article ID in the URL.

	//ProductDetailPage.js
	import { useParams } from "react-router-dom";

	function ProductDetailPage(){
		const params = useParams();
		
		return (
			<>
			<h1>Product Details!</h1>
			<p>{params.productId}</p>
			</>
		) 
	}

	export default ProductDetailPage;

-------Absolute and relative paths--------
Absolute Paths are the routes that start with '/'
Relative paths dont start with '/'

‚úÖRelative Prop:
It is a property which is by default set to "route". So, it's relative to the route definitions.
But it can take another value "path".
React Router will instead take a look at the currently active path and simply remove one segment from that path.

	<Link to=".." relative="path"> Back </Link>

------Index Routes-----
It's the default route that should be displayed if the parent route's path is currently active.
Path property to that route is not required as we specified to use parent's route path.

	const router = createBrowserRouter([
	{
		path: '/',
		element:<RootLayout/>,
		errorElement: <ErrorPage/>,
	
		children: [
		{
			index:true,
			element: <HomePage />
		},
		{
			path: 'products',
			element: <ProductsPage />
		},
		{
			path: 'products/:productId',
			element: <ProductDetailPage/>
		}
		]
	},
	]);

	---------Loader---------
Each route can define a "loader" function to provide data to the route element before it renders.
For Example:
	createBrowserRouter([
	{
		element: <Teams />,
		path: "teams",
		loader: async () => {
		return fakeDb.from("teams").select("*");
		},
		children: [
		{
			element: <Team />,
			path: ":teamId",
			loader: async ({ params }) => {
			return fetch(`/api/teams/${params.teamId}.json`);
			},
		},
		],
	},
	]);

Route loaders are route-level functions that can specify arbitrary data requirements for that route. They can be used to:

1Ô∏è‚É£Fetch data from a server
2Ô∏è‚É£Delay the loading of a route until an asynchronous action has been completed
3Ô∏è‚É£Prepare the route to be rendered

üòÉWhy Should i use route loaders? Why are they cool?

Routes requiring data are nothing new, but the way React Location orchestrates these requirements is where the magic happens. In a traditional React application, usually, the route is rendered immediately, and the data is fetched asynchronously either via a custom hook or a suspense boundary that is hit. This is a great way to get data from a server, but it also means that the route is rendered before the data is available. It introduces the need for a lot of boilerplate code to handle the asynchronous data fetching and even worse, spinners everywhere. This is usually a sub-optimal user experience, and with route loaders, it's one that we can avoid!

üìûRoute loaders are called when:

1Ô∏è‚É£A route is matched for navigation
2Ô∏è‚É£A route is matched for preloading

üî≠Route Loader objects
Why do route loaders need to return an object? Because multiple route loaders can be matched at once. For example:

1Ô∏è‚É£A teams route might have a route loader that fetches a list of teams
2Ô∏è‚É£A teams/:teamId route might have another loader that fetches the individual team details.

At the teams route, you would return an object with the teams key, and at the teams/:teamId route, you would return an object with the team key.
Example: 
	const routes = [
	{
		path: 'teams',
		loader: async () => ({
		teams: await fetch('/api/teams'),
		}),
		children: [
		{
			path: ':teamId',
			loader: async ({ params: { teamId } }) => ({
			team: await fetch(`/api/teams/${teamId}`),
			}),
		},
		],
	},
	]

Each of these loader objects will be merged together into a single object that can be consumed in your routes or sub-loaders:

	{
		"teams": [...],
		"team": {...}
	}

üìàParallelized Execution Vs Serial Execution
Route loaders are parallelized by default. This means that when a route is matched, each of the loaders it matches will be executed at the same time. This is great for performance, but it also means that if one of the loaders fails, the others will still be executed. It also means that if one of your loaders depends on the data of a parent, it will need to de-opt and await the promise of its parent before proceeding.

Here is an example of a route loader that depends on the data of a parent:
	const routes = [
	{
		path: 'teams',
		loader: async () => ({
		teams: await fetch('/api/teams'),
		}),
		children: [
		{
			path: ':teamId',
			loader: async ({ params: { teamId } }, { parentMatch }) => ({
			// This route will wait for the parent loaderPromise to resolve before finding the individual team
			team: await parentMatch.loaderPromise.then(({ teams }) =>
				teams.find((team) => team.id === teamId)
			),
			}),
		},
		],
	},
	]

ü™ùUsing Loader data in Routes with the useMatch hook
Loader data is made available to elements via the useMatch hook. Calling "useMatch" in an element will return the closest match to the component you call it.
Example: 
	const routes = [
	{
		path: 'teams',
		element: <Teams />,
		loader: async () => ({
		teams: await fetch('/api/teams'),
		}),
		children: [
		{
			path: ':teamId',
			element: <Team />,
			loader: async ({ params: { teamId }, parentMatch }) => ({
			// This route will wait for the parent loaderPromise to resolve before finding the individual team
			team: await parentMatch.loaderPromise.then(({ teams }) =>
				teams.find((team) => team.id === teamId)
			),
			}),
		},
		],
	},
	]
	
	function Teams() {
	const {
		data: { teams },
	} = useMatch()
	}
	
	function Team() {
	const {
		data: { team },
	} = useMatch()
	}

‚úÖRoute Loading Caching
By default, route loaders are called for new or changed routes in the route hierarchy that resulted from a navigation.

‚ùåHandling Loader Errors:
Errors caught from the loader function promise are stored in the match state for you to handle in your errorElement route element.
To access the error, you can use the error property on the match state:

	const routes = [
	{
		path: 'teams',
		loader: async () => {
		throw new Error('Something went wrong!')
		},
		errorElement: <TeamsError />,
	},
	]
	
	function TeamsError() {
	const { error } = useMatch()
	
	return (
		<div>
		<div>Couldn't load teams!</div>
		<div>{error.message}</div>
		</div>
	)
	}
IMPORTANT! : ‚ö†Ô∏è
Loader()'s must return null or any other value.
You should make sure that you do add an extra return null statement in all if statement branches where nothing would be returned otherwise to avoid errors.


------Returning Responses in Loader------

const res = new Response();

The Response() constructor creates a new Response object.

Three ways in which it can be called:
1Ô∏è‚É£new Response()
2Ô∏è‚É£new Response(body)
3Ô∏è‚É£new Response(body, options)


ü§îParameters
body (Optional)
An object defining a body for the response. This can be null (which is the default value), or one of:
	- Blob
	- ArrayBuffer
	- TypedArray
	- DataView
	- FormData
	- ReadableStream
	- URLSearchParams
	- String
	- string literal

options (Optional)
An options object containing any custom settings that you want to apply to the response, or an empty object (which is the default value). The possible options are:

	- status
	The status code for the response, e.g., 200.

	- statusText
	The status message associated with the status code, e.g., OK.

	- headers
	Any headers you want to add to your response, contained within a Headers object or object literal of String key/value pairs (see HTTP headers for a reference).

whenever you return such a response in your loaders, the React Router package will automatically extract the data from your response when using useLoaderData.

You don't need to manually extract the data from the response (which is returned by fetch as the fetch also returns a Response object). Since, react router will handle the extraction behind the scenes, you can simply return that response.

‚ö†Ô∏èWhat kind of code goes into Loader()'s?
Any kind of code being browser API's (like localstorage, fetch, etc) can be used.

But, code like Hooks (like useState(), useEffect()..etc) can't be used here.

For more info:
https://react-location.tanstack.com/guides/route-loaders



----ü™ùuseLoaderData Hook----

React Router will actually check if a promise is returned and automatically get the resolved data from that promise for you. So you don't need to worry about whether you are returning a promise here or not, you will always get the final data that would be yielded by the promise with help of useLoaderData.
This hook provides the value returned from your route loader.

After route actions are called, the data will be revalidated automatically and return the latest result from your loader.

IMPORTANT! : ‚ö†Ô∏è
It can be used on a component which is either at a lower level or in that component itself. It means you can use useLoadeData() in the element that's assigned to a route AND in all components that might be used inside that element.

ü§îWhere should be Loader() code be stored?
common pattern and a recommendation is that you do actually put that loader code into your component file where you need it (Route Page). So to the page component file where you want to add the loader to be precise, exported and used where you defined your routes.

üèÉ‚Äç‚ôÇÔ∏èWhen exactly that loader is Executed?
The loader for a page will be called right when we start navigating to that page. So not after the page component has been rendered, but before we actually go there.

React router will actually wait for the data to be fetched, so for the loader to be finished before it then renders the page with the fetched data.

The advantage of this approach is that you can rely on the data being there once the component is being rendered. You don't need to worry about whether the data is there yet or not and therefore you don't need to record a loading state on this component.

The downside is that we have this delay where it looks to the user as if nothing is happening.

React Router gives us a special hook (useNavigation()) which we can use to check the current route transitions state. So, to find out if a transition has been initiated and we're currently still waiting for data to arrive, or if we're done.

Navigation object has a couple of properties, the state property being the most important one. This is simply a string which is either idle, loading, or submitting.

IMPORTANT! : ‚ö†Ô∏è
It's just important to recognize that the loading indicator won't be added on the page which you're transitioning to, but instead on some page, or a component, which is already visible on the screen when the transition is started.

------‚≠ïError Handling in the Loader function------

We can throw an Error :
	throw new Error();
or we can throw any object:
	throw {message: 'Error occured!'};
or we can throw Responses:
	throw new Response(JSON.stringify({message:'Could not fetch events.'}), {status:500});
when an error gets thrown in a loader something special happens. React router will simply render the closest errorElement.

Instead, the error element will be shown to the screen whenever an error is generated in any route related code, including loaders.

We can get the error object from another special hookü™ù namely 'useRouteError'. It reutrns an Error Object

	const error = useRouteError();
 - Shape of the error object depends on what kind of object you throw
 (like response, object);

 if you throw a response, it will include a status.
we can utilize it as given below:
//Error.js
	import { useRouteError } from "react-router-dom";
	import PageContent from "../components/PageContent";

	function ErrorPage(){
	const error = useRouteError();

	let title = 'An Error Occured!';
	let message = 'Something went wrong!';

	if(error.status === 500){
		message = JSON.parse(error.data).message;
	}

	if(error.status === 404){
		title = "Not found!";
		message = "Could not found resource or page.";
	}
	return (
		<PageContent title = {title} >
			<p>{message}</p>
		</PageContent>
	)
	}

	export default ErrorPage;

----json() utility function----
It is a function that is provided by 'react-router-dom'

json() is a function that creates a response object that includes data in the json format and you don't need to convert it to json manually. Instead, that will be done for you and you can pass a second argument where you can set that extra response metadata like this status and in the place where you use that response data you also don't have to parse the json format manually because the parsing will now be done by React router for you.


defaultValue attribute on JSX elements:

-------useRouteLoaderData Hookü™ù--------
This hook makes the data at any currently rendered route available anywhere in the tree. This is useful for components deep in the tree needing data from routes much farther up, as well as parent routes needing the data of child routes deeper in the tree.

React Router stores data internally with deterministic, auto-generated route ids, but you can supply your own route id to make this hook much easier to work with. Consider a router with a route that defines an id:

	createBrowserRouter([
	{
		path: "/",
		loader: () => fetchUser(),
		element: <Root />,
		id: "root",
		children: [
		{
			path: "jobs/:jobId",
			loader: loadJob,
			element: <JobListing />,
		},
		],
	},
	]);

const user = useRouteLoaderData("root");
The only data available is the routes that are currently rendered. If you ask for data from a route that is not currently rendered, the hook will return undefined.

------Route Actions (much similar to Loaders)------
Route actions are the "writes" to route loader "reads". They provide a way for apps to perform data mutations with simple HTML and HTTP semantics while React Router abstracts away the complexity of asynchronous UI and revalidation. This gives you the simple mental model of HTML + HTTP (where the browser handles the asynchrony and revalidation) with the behavior and UX capabilities of modern SPAs.

This feature only works if using a data router like createBrowserRouter.

Actions are called whenever the app sends a non-get submission ("post", "put", "patch", "delete") to your route. This can happen in a few ways:

----params in actions----
Route params are parsed from dynamic segments and passed to your action. This is useful for figuring out which resource to mutate:

	<Route
	path="/projects/:projectId/delete"
	action={({ params }) => {
		return fakeDeleteProject(params.projectId);
	}}
	/>

----request in actions----
This is a Fetch Request instance being sent to your route. The most common use case is to parse the FormData from the request

	<Route
	action={async ({ request }) => {
		let formData = await request.formData();
		// ...
	}}
	/>

----Returning Responses----
While you can return anything you want from an action and get access to it from useActionData, you can also return a web Response.

----Throwing in Actions----
You can throw in your action to break out of the current call stack (stop running the current code) and React Router will start over down the "error path".

	<Route
	action={async ({ params, request }) => {
		const res = await fetch(
		`/api/properties/${params.id}`,
		{
			method: "put",
			body: await request.formData(),
		}
		);
		if (!res.ok) throw res;
		return { ok: true };
	}}
	/>

-------Form Component from 'react-router-dom'--------
The Form component is a wrapper around a plain HTML form that emulates the browser for client side routing and data mutations. It is not a form validation/state management library like you might be used to in the React ecosystem (for that, we recommend the browser's built in HTML Form Validation and data validation on your backend server).

The request will no be sended to backend automatically but to the Action.

import { Form } from "react-router-dom";

	function NewEvent() {
	return (
		<Form method="post" action="/events">
		<input type="text" name="title" />
		<input type="text" name="description" />
		<button type="submit">Create</button>
		</Form>
	);
	}


IMPORTANT! : ‚ö†Ô∏è
This feature only works if using a data router. Make sure your inputs have names or else the FormData will not include that field's value.


All of this will trigger state updates to any rendered useNavigation hooks so you can build pending indicators and optimistic UI while the async operations are in-flight.

   ----Action----
The url to which the form will be submitted, just like HTML form action. The only difference is the default action. With HTML forms, it defaults to the full URL. With <Form>, it defaults to the relative URL of the closest route in context.

Consider the following routes and components:
	function ProjectsLayout() {
	return (
		<>
		<Form method="post" />
		<Outlet />
		</>
	);
	}

	function ProjectsPage() {
	return <Form method="post" />;
	}

	<DataBrowserRouter>
	<Route
		path="/projects"
		element={<ProjectsLayout />}
		action={ProjectsLayout.action}
	>
		<Route
		path=":projectId"
		element={<ProjectsPage />}
		action={ProjectsPage.action}
		/>
	</Route>
	</DataBrowserRouter>;

If the the current URL is "/projects/123", the form inside the child route, ProjectsPage, will have a default action as you might expect: "/projects/123". In this case, where the route is the deepest matching route, both <Form> and plain HTML forms have the same result.

But the form inside of ProjectsLayout will point to "/projects", not the full URL. In other words, it points to the matching segment of the URL for the route in which the form is rendered.

This helps with portability as well as co-location of forms and their action handlers when if you add some convention around your route modules.

If you need to post to a different route, then add an action prop:

	<Form action="/projects/new" method="post" />

   ---Method---
This determines the HTTP verb to be used. The same as plain HTML form method, except it also supports "put", "patch", and "delete" in addition to "get" and "post". The default is "get".

 - GET submissions
The default method is "get". Get submissions will not call an action. Get submissions are the same as a normal navigation (user clicks a link) except the user gets to supply the search params that go to the URL from the form.

<Form method="get" action="/products">
  <input
    aria-label="search products"
    type="text"
    name="q"
  />
  <button type="submit">Search</button>
</Form>
Let's say the user types in "running shoes" and submits the form. React Router emulates the browser and will serialize the form into URLSearchParams and then navigate the user to "/products?q=running+shoes". It's as if you rendered a <Link to="/products?q=running+shoes"> as the developer, but instead you let the user supply the query string dynamically.

Your route loader can access these values most conveniently by creating a new URL from the request.url and then load the data.

	<Route
	path="/products"
	loader={async ({ request }) => {
		let url = new URL(request.url);
		let searchTerm = url.searchParams.get("q");
		return fakeSearchProducts(searchTerm);
	}}
	/>
 - Mutation Submissions
All other methods are "mutation submissions", meaning you intend to change something about your data with POST, PUT, PATCH, or DELETE. Note that plain HTML forms only support "post" and "get", we tend to stick to those two as well.

When the user submits the form, React Router will match the action to the app's routes and call the <Route action> with the serialized FormData. When the action completes, all of the loader data on the page will automatically revalidate to keep your UI in sync with your data.

The method will be available on request.method inside the route action that is called. You can use this to instruct your data abstractions about the intent of the submission.

	<Route
	path="/projects/:id"
	element={<Project />}
	loader={async ({ params }) => {
		return fakeLoadProject(params.id);
	}}
	action={async ({ request, params }) => {
		switch (request.method) {
		case "PUT": {
			let formData = await request.formData();
			let name = formData.get("projectName");
			return fakeUpdateProject(name);
		}
		case "DELETE": {
			return fakeDeleteProject(params.id);
		}
		default: {
			throw new Response("", { status: 405 });
		}
		}
	}}
	/>;

	function Project() {
	let project = useLoaderData();

	return (
		<>
		<Form method="put">
			<input
			type="text"
			name="projectName"
			defaultValue={project.name}
			/>
			<button type="submit">Update Project</button>
		</Form>

		<Form method="delete">
			<button type="submit">Delete Project</button>
		</Form>
		</>
	);
	}
As you can see, both forms submit to the same route but you can use the request.method to branch on what you intend to do. After the actions completes, the loader will be revalidated and the UI will automatically synchronize with the new data.

----formData()----

Refer this resource!
https://developer.mozilla.org/en-US/docs/Web/API/FormData/FormData

 --get()--
The get() method of the FormData interface returns the first value associated with a given key from within a FormData object. If you expect multiple values and want all of them, use the getAll() method instead.

ü§îParameters

1Ô∏è‚É£name
A string representing the name of the key you want to retrieve.

-----redirect-----
Because you can return or throw responses in loaders and actions, you can use redirect to redirect to another route.

	import { redirect } from "react-router-dom";

	const loader = async () => {
	const user = await getUser();
	if (!user) {
		return redirect("/login");
	}
	return null;
	};

It's really just a shortcut for this:

	new Response("", {
	status: 302,
	headers: {
		Location: someUrl,
	},
	});

It's recommended to use redirect in loaders and actions rather than useNavigate in your components when the redirect is in response to data.

-------useSubmit Hookü™ù---------
The imperative version of <Form> that lets you, the programmer, submit a form instead of the user.

For example, submitting the form every time a value changes inside the form:
	import { useSubmit, Form } from "react-router-dom";

	function SearchField() {
	let submit = useSubmit();
	return (
		<Form
		onChange={(event) => {
			submit(event.currentTarget);
		}}
		>
		<input type="text" name="search" />
		<button type="submit">Search</button>
		</Form>
	);
	}

This can also be useful if you'd like to automatically sign someone out of your website after a period of inactivity. In this case, we've defined inactivity as the user hasn't navigated to any other pages after 5 minutes.

	import { useSubmit, useLocation } from "react-router-dom";
	import { useEffect } from "react";

	function AdminPage() {
	useSessionTimeout();
	return <div>{/* ... */}</div>;
	}

	function useSessionTimeout() {
	const submit = useSubmit();
	const location = useLocation();

	useEffect(() => {
		const timer = setTimeout(() => {
		submit(null, { method: "post", action: "/logout" });
		}, 5 * 60_000);

		return () => clearTimeout(timer);
	}, [submit, location]);
	}
--Submit target--
The first argument to submit accepts many different values. You can submit any form or form input element:

// input element events
<input onChange={(event) => submit(event.currentTarget)} />;

// React refs
let ref = useRef();
<button ref={ref} />;
submit(ref.current);
You can submit FormData:

let formData = new FormData();
formData.append("cheese", "gouda");
submit(formData);


--Submit options--
The second argument is a set of options that map directly to form submission attributes:

submit(null, {
  action: "/logout",
  method: "post",
});

// same as
<Form action="/logout" method="post" />;

-------useActionData Hookü™ù----------
This hook provides the returned value from the previous navigation's action result, or undefined if there was no submission.

‚úÖIt gives us access to the data returned by our action,in this case, not by the loader, but by the action and it gives us access to the closest action.

	import { useActionData } from "react-router-dom";

	function SomeComponent() {
	let actionData = useActionData();
	// ...
	}

The most common use-case for this hook is form validation errors. If the form isn't right, you can return the errors and let the user try again:

	import {
	useActionData,
	Form,
	redirect,
	} from "react-router-dom";

	export default function SignUp() {
	const errors = useActionData();

	return (
		<Form method="post">
		<p>
			<input type="text" name="email" />
			{errors?.email && <span>{errors.email}</span>}
		</p>

		<p>
			<input type="text" name="password" />
			{errors?.password && <span>{errors.password}</span>}
		</p>

		<p>
			<button type="submit">Sign up</button>
		</p>
		</Form>
	);
	}

	export async function action({ request }) {
	const formData = await request.formData();
	const email = formData.get("email");
	const password = formData.get("password");
	const errors = {};

	// validate the fields
	if (typeof email !== "string" || !email.includes("@")) {
		errors.email =
		"That doesn't look like an email address";
	}

	if (typeof password !== "string" || password.length < 6) {
		errors.password = "Password must be > 6 characters";
	}

	// return data if we have errors
	if (Object.keys(errors).length) {
		return errors;
	}

	// otherwise create the user and redirect
	await createUser(email, password);
	return redirect("/dashboard");
	}

------Reusing Actions via Request Methods------
Request object in 'Actions and Loaders' functions has a property 'method'
	request.method
generated by the react router.
setted by the 'Form' component that is available in 'react-router-dom'

-------useFetcher Hookü™ù---------
In HTML/HTTP, data mutations and loads are modeled with navigation: <a href> and <form action>. Both cause a navigation in the browser. The React Router equivalents are <Link> and <Form>.

But sometimes you want to call a loader outside of navigation, or call an action (and get the data on the page to revalidate) without changing the URL. Or you need to have multiple mutations in-flight at the same time.

Many interactions with the server aren't navigation events. This hook lets you plug your UI into your actions and loaders without navigating.

This feature only works if using a data router, see Picking a Router

This is useful when you need to:

‚úÖfetch data not associated with UI routes (popovers, dynamic forms, etc.)
‚úÖsubmit data to actions without navigating (shared components like a newsletter sign ups)
‚úÖhandle multiple concurrent submissions in a list (typical "todo app" list where you can ‚úÖclick multiple buttons and all should be pending at the same time)
‚úÖinfinite scroll containers

If you're building a highly interactive, "app like" user interface, you will useFetcher often.

	import { useFetcher } from "react-router-dom";

	function SomeComponent() {
	const fetcher = useFetcher();

	// call submit or load in a useEffect
	React.useEffect(() => {
		fetcher.submit(data, options);
		fetcher.load(href);
	}, [fetcher]);

	// build your UI with these properties
	fetcher.state;
	fetcher.formData;
	fetcher.formMethod;
	fetcher.formAction;
	fetcher.data;

	// render a form that doesn't cause navigation
	return <fetcher.Form />;
	}
Fetchers have a lot of built-in behavior:

‚úÖAutomatically handles cancellation on interruptions of the fetch
‚úÖWhen submitting with POST, PUT, PATCH, DELETE, the action is called first
	 - After the action completes, the data on the page is revalidated to capture any mutations that may have happened, automatically keeping your UI in sync with your server state
‚úÖWhen multiple fetchers are inflight at once, it will
	 - commit the freshest available data as they each land
	 - ensure no stale loads override fresher data, no matter which order the responses return
‚úÖHandles uncaught errors by rendering the nearest errorElement (just like a normal navigation from <Link> or <Form>)
‚úÖWill redirect the app if your action/loader being called returns a redirect (just like a normal navigation from <Link> or <Form>)

--fetcher.state--
You can know the state of the fetcher with fetcher.state. It will be one of:

‚úÖidle - nothing is being fetched.
‚úÖsubmitting - A route action is being called due to a fetcher submission using POST, PUT, PATCH, or DELETE
‚úÖloading - The fetcher is calling a loader (from a fetcher.load) or is being revalidated after a separate submission or useRevalidator call

--fetcher.Form--
Just like <Form> except it doesn't cause a navigation. (You'll get over the dot in JSX ... we hope!)

	function SomeComponent() {
	const fetcher = useFetcher();
	return (
		<fetcher.Form method="post" action="/some/route">
		<input type="text" />
		</fetcher.Form>
	);
	}

--fetcher.load()--
Loads data from a route loader.

	import { useFetcher } from "react-router-dom";

	function SomeComponent() {
	const fetcher = useFetcher();

	useEffect(() => {
		if (fetcher.state === "idle" && !fetcher.data) {
		fetcher.load("/some/route");
		}
	}, [fetcher]);

	return <div>{fetcher.data || "Loading..."}</div>;
	}
Although a URL might match multiple nested routes, a fetcher.load() call will only call the loader on the leaf match (or parent of index routes).

If you find yourself calling this function inside of click handlers, you can probably simplify your code by using <fetcher.Form> instead.

IMPORTANT! : ‚ö†Ô∏è
Any fetcher.load calls that are active on the page will be re-executed as part of revalidation (either after a navigation submission, another fetcher submission, or a useRevalidator() call)

--fetcher.submit()--
The imperative version of <fetcher.Form>. If a user interaction should initiate the fetch, you should use <fetcher.Form>. But if you, the programmer are initiating the fetch (not in response to a user clicking a button, etc.), then use this function.

For example, you may want to log the user out after a certain amount of idle time:

	import { useFetcher } from "react-router-dom";
	import { useFakeUserIsIdle } from "./fake/hooks";

	export function useIdleLogout() {
	const fetcher = useFetcher();
	const userIsIdle = useFakeUserIsIdle();

	useEffect(() => {
		if (userIsIdle) {
		fetcher.submit(
			{ idle: true },
			{ method: "post", action: "/logout" }
		);
		}
	}, [userIsIdle]);
	}
If you want to submit to an index route, use the ?index param.

--fetcher.data--
The returned data from the loader or action is stored here. Once the data is set, it persists on the fetcher even through reloads and resubmissions.

	function ProductDetails({ product }) {
	const fetcher = useFetcher();

	return (
		<details
		onToggle={(event) => {
			if (
			event.currentTarget.open &&
			fetcher.state === "idle" &&
			!fetcher.data
			) {
			fetcher.load(`/product/${product.id}/details`);
			}
		}}
		>
		<summary>{product.name}</summary>
		{fetcher.data ? (
			<div>{fetcher.data}</div>
		) : (
			<div>Loading product details...</div>
		)}
		</details>
	);
	}
--fetcher.formData--
When using <fetcher.Form> or fetcher.submit(), the form data is available to build optimistic UI.

	function TaskCheckbox({ task }) {
	let fetcher = useFetcher();

	// while data is in flight, use that to immediately render
	// the state you expect the task to be in when the form
	// submission completes, instead of waiting for the
	// network to respond. When the network responds, the
	// formData will no longer be available and the UI will
	// use the value in `task.status` from the revalidation
	let status =
		fetcher.formData?.get("status") || task.status;

	let isComplete = status === "complete";

	return (
		<fetcher.Form method="post">
		<button
			type="submit"
			name="status"
			value={isComplete ? "incomplete" : "complete"}
		>
			{isComplete ? "Mark Incomplete" : "Mark Complete"}
		</button>
		</fetcher.Form>
	);
	}
--fetcher.formAction--
Tells you the action url the form is being submitted to.

	<fetcher.Form action="/mark-as-read" />;

	// when the form is submitting
	fetcher.formAction; // "mark-as-read"

--fetcher.formMethod--
Tells you the method of the form being submitted: get, post, put, patch, or delete.

	<fetcher.Form method="post" />;

	// when the form is submitting
	fetcher.formMethod; // "post"

----------Deferring Data Fetching with defer()----------
we can defer (to leave something until a later time) loading and tell React router that we actually wanna render a component already even though the data is not fully there yet.

 ---defer()---
This utility allows you to defer values returned from loaders by passing promises instead of resolved values.

	async function loadEvents() {
		const response = await fetch('http://localhost:8080/events');
		if (!response.ok) {
			// return {isError: true, message: 'Could not fetch events.'}
			throw json({ message: 'Could not fetch events.' }, { status: 500 });

		} else {
			return response;
		}
	}
	export async function loader() {
		defer({
			events: loadEvents()
		})
	}

The function that is provided to the properties in the defer object must be returning a promise and it should be a result of calling that function.

Now, where we are accessing the data (i.e the components where we have written the logic for useLoaderData), we have the data as the following keys

for Exapmle in above case:
 const data = useLoaderData();

 data = {
	events: []
 }

This events key will hold a promise as a value.

----<Await> Component----
Used to render deferred values with automatic error handling. Make sure to review the Deferred Data Guide since there are a few APIs that work together with this component.

this componenet will wait for the data (resolved data to be there and )

IMPORTANT! : ‚ö†Ô∏è
<Await> expects to be rendered inside of a <React.Suspense> or <React.SuspenseList> parent to enable the fallback UI. (to show a fallback whilst we're waiting for these events to be fetched.)

---children---
Can either be React elements or a function.

When using a function, the value is provided as the only parameter.

	<Await resolve={reviewsPromise}>
	{(resolvedReviews) => <Reviews items={resolvedReviews} />}
	</Await>
When using React elements, useAsyncValue will provide the data:

	<Await resolve={reviewsPromise}>
	<Reviews />
	</Await>;

	function Reviews() {
	const resolvedReviews = useAsyncValue();
	return <div>{/* ... */}</div>;
	}

---errorElement---
The error element renders instead of the children when the promise rejects. You can access the error with useAsyncError.

If the promise rejects, you can provide an optional errorElement to handle that error in a contextual UI via the useAsyncError hook.

	<Await
	resolve={reviewsPromise}
	errorElement={<ReviewsError />}
	>
	<Reviews />
	</Await>;

	function ReviewsError() {
	const error = useAsyncError();
	return <div>{error.message}</div>;
	}

If you do not provide an errorElement, the rejected value will bubble up to the nearest route-level errorElement and be accessible via the useRouteError hook.

---resolve---
Takes a promise returned from a deferred loader value to be resolved and rendered.

	import {
	defer,
	Route,
	useLoaderData,
	Await,
	} from "react-router-dom";

	// given this route
	<Route
	loader={async () => {
		let book = await getBook();
		let reviews = getReviews(); // not awaited
		return defer({
		book,
		reviews, // this is a promise
		});
	}}
	element={<Book />}
	/>;

	function Book() {
	const {
		book,
		reviews, // this is the same promise
	} = useLoaderData();
	return (
		<div>
		<h1>{book.title}</h1>
		<p>{book.description}</p>
		<React.Suspense fallback={<ReviewsSkeleton />}>
			<Await
			// and is the promise we pass to Await
			resolve={reviews}
			>
			<Reviews />
			</Await>
		</React.Suspense>
		</div>
	);
	}


Another Exapmle: 
	import EventsList from '../components/EventsList';
	import { Await, defer, json, useLoaderData } from 'react-router-dom';
	import { Suspense } from 'react';
	function EventsPage() {
	const data = useLoaderData();
	// if(data.isError){
	//   return <p>{data.message}</p>
	// }
	const events = data.events;
	return (
		<Suspense fallback={<p>Loading.....</p>}>
		<Await resolve={events}>
		{(loadedEvents) => {<EventsList events={loadedEvents}/>}}
		</Await>
		</Suspense>
	);
	}

	export default EventsPage;
	async function loadEvents() {
	const response = await fetch('http://localhost:8080/events');
	if (!response.ok) {
		// return {isError: true, message: 'Could not fetch events.'}
		throw json({ message: 'Could not fetch events.' }, { status: 500 });

	} else {
		return await response.json();
	}
	}
	export async function loader() {
	defer({
		events: loadEvents()
	})
	}

IMPORTANT! : ‚ö†Ô∏è
Here we have to manually parse the data that is coming from the action or loader.

----------Controlling which data to be deffered----------
await is your lever, your switch for controlling which data should be awaited before moving to this page, and which data should be deferred So, where you wanna load the data after moving to the page.

-----------Section 21: Adding Authentication To React Appsüîí----------
Authentication is needed if content should be protected (not accessible by everyone)

Getting Permission:
1Ô∏è‚É£Client sends a Request that contains User Credentials

2Ô∏è‚É£Backend,then validates the Credentials or creates a new User according to the request, or need.

3Ô∏è‚É£If the Credentials are correct then server sends the response (Yes/No) that the user is granted permission to view the resources. But a "Yes" alone is not enough to then access protected resources (API endpoints)

Now to erradicate the above problem, we could use 2 solutions:

1Ô∏è‚É£Server-Side Sessions 

Here, we store unique identifier on server (map it to a specific client with help of an ID), send same to client.(After a user logged in and authenticated)

Client then send backs the identifier along with requests to protected resources.

Popular for full stack application where you dont have decoupled frontend and Backend (Not ideal for REACT).

2Ô∏è‚É£Authentication Tokens

On the server, after the user was authenticated or verified or send the valid user credentials, we create (but not store) "permission" token (which is a string created using an algorithm and has some information) on server, send token to client.

Its validity can only be checked by the backend (as it created by backend with some private key which is known to backend only).

Client send token along with requests to protected resources.

You can add the token in the request headers under Authorization header: 
	'Authorization' : 'Bearer ' + token
attach the token to the localstorage.


React Context can be used to handle tokens all over the app and reflect UI changes based on authentication.

Using 'react-router-dom', we can also use that package for handling tokens and we could to our root route which in the end wraps all other routes and there we could add a loader, which simply takes a look at local storage and extracts the token from local storage and that token would then be available through the loader data of that root route in all other routes.

The best thing about that is that React Router will automatically reevaluate that if we for example, log out, if we submit that logout form. So it will then re fetch that token and for example determine that the token doesn't exist and then update all the pages that use that loader data.

Therefore ensures that we always have the latest information about that token.



-------Query Parameters-------

The useSearchParams hook is used to read and modify the query string in the URL for the current location. Like React's own useState hook, useSearchParams returns an array of two values: the current location's search params and a function that may be used to update them. Just as React's useState hook, setSearchParams also supports functional updates. Therefore, you may provide a function that takes a searchParams and returns an updated version.

	import * as React from "react";
	import { useSearchParams } from "react-router-dom";

	function App() {
	let [searchParams, setSearchParams] = useSearchParams();

	function handleSubmit(event) {
		event.preventDefault();
		// The serialize function here would be responsible for
		// creating an object of { key: value } pairs from the
		// fields in the form that make up the query.
		let params = serializeFormQuery(event.target);
		setSearchParams(params);
	}

	return (
		<div>
		<form onSubmit={handleSubmit}>{/* ... */}</form>
		</div>
	);
	}

The setSearchParams function works like navigate, but only for the search portion of the URL. Also note that the second arg to setSearchParams is the same type as the second arg to navigate.

Example: 
	import * as React from "react";
	import { View, SearchForm, TextInput } from "react-native";
	import { useSearchParams } from "react-router-native";

	function App() {
	let [searchParams, setSearchParams] = useSearchParams();
	let [query, setQuery] = React.useState(
		searchParams.get("query")
	);

	function handleSubmit() {
		setSearchParams({ query });
	}

	return (
		<View>
		<SearchForm onSubmit={handleSubmit}>
			<TextInput value={query} onChangeText={setQuery} />
		</SearchForm>
		</View>
	);
	}

Exmple of a Query Parameter: 
http://localhost:8080/users?category=audience&age=21

	{
		category:audience,
		age:21
	}
------URL constructor-------
The URL interface is used to parse, construct, normalize, and encode URLs. It works by providing properties which allow you to easily read and modify the components of a URL.

You normally create a new URL object by specifying the URL as a string when calling its constructor, or by providing a relative URL and a base URL. You can then easily read the parsed components of the URL or make changes to the URL.
More Info:
https://developer.mozilla.org/en-US/docs/Web/API/URL

------Protecting Routes-----
Certain routes here should not always be accessible. Because we shouldn't be able to reach these routes if we're not logged in because we won't be able to use them correctly anyways. 

So how can we add this kind of protection then?

We could utilize a loader. A loader that simply checks if we have a token.

	export function checkAuthLoader(){
		const token = getAuthToken();
		if(!token){
			return redirect('/auth');
		}
		return null;
	}

Now simply add the loader to those routes which needs to be protected.

------Adding automatic logout------
We need a way to check whether there is a auth token in storage whenever the root component loads.
We can use useEffect in RootLayout of the app as specified below.

	function RootLayout() {
	// const navigation = useNavigation();
	const token = useLoaderData();
	const submit = useSubmit();

	useEffect(()=>{
		if(!token){
		return;
		}
		setTimeout(()=>{
		submit(null, {action:'/logout',method:'post'});
		},timeout-time);
	},[token, submit])


	return (
		<>
		<MainNavigation />
		<main>
			{/* {navigation.state === 'loading' && <p>Loading...</p>} */}
			<Outlet />
		</main>
		</>
	);
	}

This solution still has the flaw:
we might have logged in. Then we were away for 10 minutes. Then we reloaded this application and then therefore, this effect was triggered again. We found a token in the local storage, because we did log in 10 minutes ago, but now we reset that timer to specified timer.

 - that‚Äôs not realistic
it's not enough to always set this to specified timer, Instead we need to manage and register, the actual token expiration.

And to do that, we should go to our action that's triggered

Solution is, the action where the user is being authenticate , We can set a item in localStorage that will define the time.

	const expiration = new Date();
	expiration.setHours(expiration.getHours() + 1);
	localStorage.setItem('expiration', expiration.toISOString());




	//RootLayout.js
	useEffect(() => {
		if (!token) {
		return;
		}

		if(token === 'EXPIRED'){
		submit(null, { action: '/logout', method: 'post' });
		}

	const tokenDuration = getTokenDuration();
	console.log(tokenDuration);

		setTimeout(() => {
		submit(null, { action: '/logout', method: 'post' });
		}, tokenDuration);
	}, [token, submit])

--------Section 22: Deployment of REACT APPS‚òÅÔ∏è----------

Development ------> Production

‚åö‚òÅÔ∏è How and what steps to be taken?
1Ô∏è‚É£ Test the App first thoroughly

2Ô∏è‚É£ Optimize the code (add lazy loading)

3Ô∏è‚É£ Build App for Production
	-> execute a script, which will output production ready code automatically.

4Ô∏è‚É£ Upload Production code to server

5Ô∏è‚É£ Configure the server, hosting provider

----Adding Lazy Loading----
	  (Optimization)

Lazy Loading - Load only when it's needed.

- Comment the import statements, import it laziliy

import() -> import dynamically when needed returns promise 

	import('path_to_that_file')
	.then(module => {can be executed functions whenever and whereever needed});

<Suspense></Suspense>:
- Import it from REACT
- <Suspense> lets you display a fallback until its children have finished loading.

Example: 
<Suspense fallback={<Loading />}>
  <Albums />
</Suspense>

lazy(): 
- Call lazy outside your components to declare a lazy-loaded React component.

- lazy lets you defer loading component‚Äôs code until it is rendered for the first time.

Example: 
import { lazy } from 'react';

const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));

---------Building the Code for Production----------

The code we wrote is not the one we are or going to upload (Its only for development).

For creating a production build we need to run:
	> npm run build
-> This will produce a code bundle with highly optimized and transformed code which is ready to be uploaded.
-> after the command is finished, it will create a build folder,
	build
	 -> static
	     -> css
		 -> js

build folder is the folder that should be deployed to a server.

js folder has all the necessary code that you wrote and all the third party packages that you are using including the react library itself.

-------Deployment---------
A React SPA (single page application) is a static Website, consists of only HTML,CSS,JS only.

Therefore, A Static site Host is Needed
 -> Netlify, Firebase Hosting
Search to Google: deploy static site

------Configuring Server: Server side vs Client side routing------

> Configure as SPA?
  
  Server Side Routing vs Client Side Routing


(/some-route)---Server--(Production-Ready React Code)---
	|												   |
	|												   |
 (Request)										   (Response)
	|										[HTML,CSS,JS (React-Code)]
	|												   |
	|-----------Client-----------------------------(/some-route)


IMPORTANT! : ‚ö†Ô∏è
when you have your application deployed on a server and a user enters a URL in the browser, what happens technically is that the browser sends a request to the server. The server then sends back a response, which of course, is in the end is this React application. So the HTML file, but also the JavaScript code that makes up this application. Now if we did not just send a request to main domain, but maybe also to some path like /posts or whatever path we have on our website, then that path also reaches the server on this initial request. And by default, the server would try to find the fitting response  for the path we requested in our request. For example, by searching for a folder with a name of some route. And of course, the server in this case would fail to find a fitting file because it doesn't have any server side logic for handling requests with different paths. What the server should instead do is always return
exactly the same HTML file and the same JavaScript code so that this path, which we requested, can be resolved on the client side by that JavaScript code we requested, so by our React app that's using React Router.

However, as mentioned, the default behavior is not that the server always returns the same file. Instead by default, it would look for a fitting file in a fitting folder based on the request we sent.
And that's why we got this question whether we want to configure this as a single page application. By answering this question with yes,
We configure the hosting site as to host it as a Single Page Application.

IMPORTANT! : ‚ö†Ô∏è
When the hosting providers not ask you whether you want to configure the app as a single page application. In such cases, you manually must set up some redirection rule that basically forwards all requests to index.html (root-page).

-------Section 24: Animating React AppsüìΩÔ∏èüçø--------
ü§øWe can add transitions using CSS transitions.

ü§øWe can add animations using CSS animations and control it in REACT with help of classes.


üôÖLimitations of using CSS Transitions and animations
 - Here, all our html code is in the dom, no matter what the animation state is.
 For Example: Modal close and open animations can only be visible to the end user, but it can be seen using devtools. The elements are always there.

 state changes can ruin the animations and transitions sometime.

------using ReactTransitionGroup-----
Its a package not created by official react team, but with help of some vibrant community of React.

It allows you to smoothly animate the elements while mounting and unmounting the elements from the DOM.

1Ô∏è‚É£It has an important component named as 'Transition'
	import Transition from 'react-transition-group/Transition';

2Ô∏è‚É£We wrap this component around a component which is then to be transitioned.

Then we add the options to it, how we want to animate:
Which are provided in the documentations.

There is also CSSTransition Component which can also be used for animations.

There are other alterantives packages for animations such as React move, React motion, React Router Transition.

More info about these React Transition Groups.
https://reactcommunity.org/react-transition-group/
https://reactcommunity.org/react-transition-group/transition


-------Section 25: Replacing Redux with React HooksüíØ--------
Building your own state management store is possible with only React. (Redux Like Store)

‚úÖSteps to follow:

1Ô∏è‚É£In the src folder create a directory named 'hooks-store' under that directory create a file named 'store.js'

		- hooks-store
			- store.js
2Ô∏è‚É£In that file create a 'globalState' varaible.

Now we also want to have a couple of places in the app where we can listen to changes in that state.

In the same file, add a variable named, 'listeners' 

We also need a couple of actions which can be dispatched.

	import {useState,useEffect} from 'react';

	let globalState = {};
	let listeners = [];
	let actions = {};

	//Custom-Hookü™ù
	export const useStore = () => {
		/*
			we need a mechanism so that we can re-render a component upon a state change.
			(HINT: useState() fits best)
			It's defined outside of my hook. So it's global.It's not recreated when we call useStore.

			we will use globalState variable, if it changes then the following component re-renders.
			
			whenever any file imports this file or something from that file gets the same shared data.
		
		*/
		
		const setState = useState(globalState)[1];
		const dispatch = (actionIdentifier, payload) => {
			const newState = actions[actionIdentifier](globalState, payload)
			globalState = {...globalState, ...newState};

			for(const listener of listeners){
				listener(globalState);
			}

		};

		useEffect(() => {
			//adding the listener
			listeners.push(setState);

			//unmounts
			return () => {
				listeners = listeners.filter(li => li !== setState);
			}
		},[setState]);

		return [globalState, dispatch];
	};

	export const initStore = (userActions, initialState) => {
		if(initialState){
			globalState = {...globalState, initialState};
		}
		actions = {...actions, ...userActions};
	}

It is usable now to now create stores of various context and configure it according to our use, thatis we can create our own actions and dispatch the actions to update the store (Central).

Listeners should be an array full of functions which we can call to update all components that are using the custom hook. It would be great that if a component is unmounted we get rid of its listeners.

OPTIMIZATION! : üî®ü§ñ
export const useStore = (shouldListen = true) => {
		const setState = useState(globalState)[1];
		const dispatch = (actionIdentifier, payload) => {
			const newState = actions[actionIdentifier](globalState, payload)
			globalState = {...globalState, ...newState};

			for(const listener of listeners){
				listener(globalState);
			}
		};

		useEffect(() => {
			//adding the listener only when it needs to
			if(shouldListen){
				listeners.push(setState);

			}
			//unmounts if it is listened.
			return () => {
				if(shouldListen){
					listeners = listeners.filter(li => li !== setState);
				}
			}
		},[setState,shouldListen]);

		return [globalState, dispatch];
	};

We can use 'shouldListen' to register a listener for this component or not because if we have a component which only uses our store to dispatch actions, then we don't want to listen to changes.

It prevents additional rendering with the help of 'React.Memo()'

For an npm package, you can also use this package named:
use-global-hook, it also provides the same functionality as we saw above.
https://www.npmjs.com/package/use-global-hook

-------Section 26: Testing React Apps (Unit Tests)üíØ--------

What is "Testing" and "Why"?
üôé‚Äç‚ôÇÔ∏è(Manual Testing):
Write Code <> Preview & Test in Browser. Its important as you will see what the end users will see.
Error-Prone: It's hard to test all possible combinations and scenarios.

ü§ñ(Automated Testing):
Not a Replacement!, But it's an addtion
You write an extra code that test your main application code.
You test the indiviual building blocks of your app.
It allows you to test ALL building blocks at once.

-----Different Kinds of Automated Testing----
you have many types of tests:
1Ô∏è‚É£Unit Tests
Test the individual building blocks (functions, components) in isolation.

Project contains alot of unit tests, typically hundred or dozens of unit tests.

The most common / important kind of tests.

2Ô∏è‚É£Integration Tests
Test the combination of multiple building blocks.
Projects typically contain a couple of integration tests.

Also important ,but focus on unit test in most cases. 

3Ô∏è‚É£End-to-End (e2e) Tests
Test complete scenarios in your app as the user would experience them.
Projects typically contain only a few e2e tests.
Important but can also be done manually (partially).

‚ùìWhat to test & How to?
(What)
Test the different building blocks.
Unit Tests: The smallest building blocks that make up your app.
(How)
Test success and error cases, but also test rare cases (but possible) results.

Technical Setup & Involved Toolsüî®
We need a tool for running our tests and asserting the results.
In particular with React, We need a tool for "simulating" (rendering) our React app / components.

For Asserting, we use 'Jest'
For Simulating, we use 'React Testing Library'
Both these tools are already there and installed and setup when you are using 'create-react-app'.

---Writing first Test for a component---

üçæConvention: Write the test as close as possible to the thing you want to test.

‚úÖThe file name for writing the test follows below convention:
	ComponentName.test.js

‚úÖTo write a test:
	- we write the test in a function 'test()' which is globally available (you don't need to import it).

	test('description_here', anonymous_function);


description_here: describes what your test does.
anonymous_function: Contains the code to test your component. Here, normally we do 3 things (3 A's):

1Ô∏è‚É£	Arrange: Set up the test data, test conditions and test environment (basically render)

2Ô∏è‚É£ Act: Run logic that should be tested (eg. execute function)

3Ô∏è‚É£ Assert: compare execution results with expected results.

To arrange we use functions like render:
	render(<Component/>) //takes JSX
	- It renders the component provided.

To act:
Can be nothing || Can be alot.

To Assert:
Check or Compare:
It utilizes various functions such as screen,expect etc.
	screen  -> property which has various functions.
	used to find elements on screen or virtual environment or testing environment. On this there are several functions available for getting the element, querying th elements and much more.

	expect -> function that is globally available to which we can pass our testing result value (nu,ber, string, DOM node, .etc)
	 -> It also has various methods and properties which van be used to check our result such as 'toBeChecked' and etc.
	
üèÉ‚Äç‚ôÇÔ∏èFor running the tests:

‚úÖThere is a script declared inside your package.json:
	> npm test
	-> provides a menu which can be used to run tests, run failed tests, run all tests, run test by name and much more. It runs a watcher which can be used to check whether a test succecced on save or not.

---Test Suits or Tests---
As your application grows,

you typically will have dozens

or maybe hundreds or thousands of tests

and to organize and group those different tests,

you often organize them into different testing suites.
For example, all the tests, belonging to one feature,

or one component of your application,could be grouped into one testing suite,


Such a testing suite can be created using a global function:

	describe('description_here', anonymous_function)

description_here: Description of category to which the different tests will then belongs.
anonymous_function: here you dont write the test itself but you put different test functions that are needed to be put together.

---------Testing User Interations and State---------
Try to write all the possible cases that can be there, for Exapmle if checing something related to 'button', then check whether before the button click and after the click.

We need to add thhe user interaction in 'add', to create the code for 'ACT' we have another package installed by the 'create-react-app' namely 'user-event' 

‚úÖ import the userEvent from the 'user-event' package.
	import userEvent from '@testing-library/user-event'

userEvent -> it is an object that help us trigger user event in the virtual screen.
	example: userEvent.click(Element);
	Element on which you want to simulate click.
'Now assert after click thing.'

----Testing Connected Tests-----
The tests simply continue to work if we use a component which has a dependency of another compoent a.k.a connected components (for example: a component which in turn uses another component)

This is happened because, render() function renders the entire component tree.

Technically, we can call this an integration test. (more than one unit / component is involved);

----Testing Asynchronous Code----
Since most of the asynchronous tasks take time to execute we can't test them immediately before execution.

Workaround: 
You can use 'find' queries on screen as a property, as these will return promises and react-testing-library will basically re-evaluate the screen a couple of times untill this succeeds.

'find' also contains various parameters to specify timeout for the test (by default it is 1s).

Test runners (anonymous_function) can be async functions
your test here can actually return a promise and then jest, test runner, will wait for this promise to resolve. So, it will wait until your test is already done.

----Working with Mocks----
Mock functions allow you to test the links between code by erasing the actual implementation of a function, capturing calls to the function (and the parameters passed in those calls), capturing instances of constructor functions when instantiated with new, and allowing test-time configuration of return values.

There are two ways to mock functions: Either by creating a mock function to use in test code, or writing a manual mock to override a module dependency.

   --  Using a mock function
Let's imagine we're testing an implementation of a function forEach, which invokes a callback for each item in a supplied array.

 - forEach.js
	export function forEach(items, callback) {
		for (let index = 0; index < items.length; index++) {
			callback(items[index]);
		}
	}

To test this function, we can use a mock function, and inspect the mock's state to ensure the callback is invoked as expected.

forEach.test.js
	const forEach = require('./forEach');

	const mockCallback = jest.fn(x => 42 + x);

	test('forEach mock function', () => {
		forEach([0, 1], mockCallback);

		// The mock function was called twice
		expect(mockCallback.mock.calls).toHaveLength(2);

		// The first argument of the first call to the function was 0
		expect(mockCallback.mock.calls[0][0]).toBe(0);

		// The first argument of the second call to the function was 1
		expect(mockCallback.mock.calls[1][0]).toBe(1);

		// The return value of the first call to the function was 42
		expect(mockCallback.mock.results[0].value).toBe(42);
	});


When we run our tests which we typically do a lot during development, we generally don't wanna send Http requests to our servers.

We don't wanna send requests because 
 - that will cause a lot of network traffic.
 - if you are not fetching data but you have some Component that sends a post request to a server, your tests might start inserting data into a database or they might start changing things on the server.

when we write tests is, we either don't even wanna send a real request or we wanna send it to some fake server.
Vaible approach will be to go with "You dont wanna send a real request"

when you write a test you don't wanna test code, which you haven't written (For example: fetch(), console.log(), .etc).
Instead, all you want is that the component behaves correctly.

For More Info about Jest(javascript Tester Tool): 
https://jestjs.io/docs/getting-started

For More Info about React Testing Library:
https://testing-library.com/docs/react-testing-library/intro/